/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * robot_dynamics.c
 *
 * Code generation for function 'robot_dynamics'
 *
 */

/* Include files */
#include "robot_dynamics.h"
#include "coriolis_100.h"
#include "coriolis_125.h"
#include "coriolis_150.h"
#include "coriolis_175.h"
#include "coriolis_200.h"
#include "inertia_100.h"
#include "inertia_125.h"
#include "inertia_150.h"
#include "inertia_175.h"
#include "inertia_200.h"
#include "mpower.h"
#include "rt_nonfinite.h"
#include "mwmathutil.h"
#include <string.h>

/* Variable Definitions */
static emlrtRSInfo h_emlrtRSI = { 14,  /* lineNo */
  "robot_dynamics",                    /* fcnName */
  "/home/jonas/matlab/21-03-03 Online Robot Ident Git/ident_functions/robot_dynamics.m"/* pathName */
};

static emlrtRSInfo i_emlrtRSI = { 27,  /* lineNo */
  "robot_dynamics",                    /* fcnName */
  "/home/jonas/matlab/21-03-03 Online Robot Ident Git/ident_functions/robot_dynamics.m"/* pathName */
};

static emlrtRSInfo u_emlrtRSI = { 73,  /* lineNo */
  "calc_model",                        /* fcnName */
  "/home/jonas/matlab/21-03-03 Online Robot Ident Git/ident_functions/robot_dynamics.m"/* pathName */
};

static emlrtDCInfo emlrtDCI = { 44,    /* lineNo */
  16,                                  /* colNo */
  "calc_model",                        /* fName */
  "/home/jonas/matlab/21-03-03 Online Robot Ident Git/ident_functions/robot_dynamics.m",/* pName */
  1                                    /* checkKind */
};

/* Function Declarations */
static void calc_model(const emlrtStack *sp, real_T m_pay_cand, const real_T
  q_global[6], const real_T qd[6], real_T M_inverse_calc[36], real_T C_calc[36],
  real_T G_calc[6], real_T M_calc[36]);

/* Function Definitions */
static void calc_model(const emlrtStack *sp, real_T m_pay_cand, const real_T
  q_global[6], const real_T qd[6], real_T M_inverse_calc[36], real_T C_calc[36],
  real_T G_calc[6], real_T M_calc[36])
{
  emlrtStack st;
  real_T t10;
  real_T t10_tmp;
  real_T t11;
  real_T t11_tmp;
  real_T t13;
  real_T t14;
  real_T t15;
  real_T t16;
  real_T t18;
  real_T t2;
  real_T t20;
  real_T t21;
  real_T t3;
  real_T t4;
  real_T t5;
  real_T t6;
  real_T t7;
  real_T t8;
  real_T t9;
  int32_T i;
  st.prev = sp;
  st.tls = sp->tls;
  if (m_pay_cand != (int32_T)muDoubleScalarFloor(m_pay_cand)) {
    emlrtIntegerCheckR2012b(m_pay_cand, &emlrtDCI, sp);
  }

  switch ((int32_T)m_pay_cand) {
   case 1:
    inertia_100(q_global, M_calc);
    coriolis_100(q_global, qd, C_calc);

    /*  GRAVLOAD - Computation of the configuration dependent vector of gravitational load forces/torques for Quantec Ultra SE 100  */
    /*  =========================================================================  */
    /*      */
    /*     G = gravload(rob,q)  */
    /*     G = rob.gravload(q)  */
    /*      */
    /*   Description::  */
    /*     Given a full set of joint variables this function computes the  */
    /*     configuration dependent vector of gravitational load forces/torques.  */
    /*      */
    /*   Input::  */
    /*     rob: robot object of Quantec Ultra SE 100 specific class  */
    /*     q:  6-element vector of generalized  */
    /*          coordinates  */
    /*     Angles have to be given in radians!  */
    /*      */
    /*   Output::  */
    /*     G:  [6x1] vector of gravitational load forces/torques  */
    /*      */
    /*   Example::  */
    /*     ---  */
    /*      */
    /*   Known Bugs::  */
    /*     ---  */
    /*      */
    /*   TODO::  */
    /*     ---  */
    /*      */
    /*   References::  */
    /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
    /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
    /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
    /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
    /*      */
    /*   Authors::  */
    /*     This is an autogenerated function!  */
    /*     Code generator written by:  */
    /*     Joern Malzahn  */
    /*     2012 RST, Technische Universitaet Dortmund, Germany  */
    /*     http://www.rst.e-technik.tu-dortmund.de  */
    /*      */
    /*   See also inertia. */
    /*      */
    /*  Copyright (C) 1993-2021, by Peter I. Corke  */
    /*  Copyright (C) 2012-2021, by Joern Malzahn  */
    /*   */
    /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
    /*   */
    /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
    /*  it under the terms of the GNU Lesser General Public License as published by  */
    /*  the Free Software Foundation, either version 3 of the License, or  */
    /*  (at your option) any later version.  */
    /*    */
    /*  RTB is distributed in the hope that it will be useful,  */
    /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
    /*  GNU Lesser General Public License for more details.  */
    /*    */
    /*  You should have received a copy of the GNU Leser General Public License  */
    /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
    /*   */
    /*  http://www.petercorke.com  */
    /*   */
    /*  The code generation module emerged during the work on a project funded by  */
    /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
    /*  acknowledge the financial support.  */
    /*  Bugfix */
    /*   In some versions the symbolic toolbox writes the constant $pi$ in */
    /*   capital letters. This way autogenerated functions might not work properly. */
    /*   To fix this issue a local variable is introduced: */
    /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
    /*     02-Mar-2021 15:05:27 */
    t2 = muDoubleScalarCos(q_global[1]);
    t3 = muDoubleScalarCos(q_global[2]);
    t4 = muDoubleScalarCos(q_global[3]);
    t5 = muDoubleScalarCos(q_global[4]);
    t6 = muDoubleScalarSin(q_global[1]);
    t7 = muDoubleScalarSin(q_global[2]);
    t8 = muDoubleScalarSin(q_global[3]);
    t9 = muDoubleScalarSin(q_global[4]);
    t10_tmp = t2 * t7;
    t10 = t10_tmp * t8 * 25.041006;
    t11_tmp = t3 * t6;
    t11 = t11_tmp * t8 * 25.041006;
    t13 = t6 * t7 * 1810.8000396;
    t15 = t10_tmp * 98.1634707;
    t16 = t11_tmp * 98.1634707;
    t18 = t5 * t6 * t7 * 369.4577454;
    t20 = t2 * t4 * t7 * t9 * 369.4577454;
    t21 = t3 * t4 * t6 * t9 * 369.4577454;
    t7 = t2 * t3;
    t14 = -(t7 * 1810.8000396);
    t3 = -(t7 * t5 * 369.4577454);
    G_calc[0] = 0.0;
    G_calc[1] = ((((((((((t2 * -4741.5597102 - t6 * 3.3267672) + t10) + t11) +
                       t13) + t14) + t15) + t16) + t18) + t3) + t20) + t21;
    G_calc[2] = ((((((((t10 + t11) + t13) + t14) + t15) + t16) + t18) + t3) +
                 t20) + t21;
    G_calc[3] = muDoubleScalarCos(q_global[1] + q_global[2]) * (t4 * 127630.0 -
      t8 * t9 * 1.883067E+6) * -0.0001962;
    G_calc[4] = ((t4 * t18 + t10_tmp * t9 * 369.4577454) + t11_tmp * t9 *
                 369.4577454) - t7 * t4 * t5 * 369.4577454;
    G_calc[5] = 0.0;
    break;

   case 2:
    inertia_125(q_global, M_calc);
    coriolis_125(q_global, qd, C_calc);

    /*  GRAVLOAD - Computation of the configuration dependent vector of gravitational load forces/torques for Quantec Ultra SE 125  */
    /*  =========================================================================  */
    /*      */
    /*     G = gravload(rob,q)  */
    /*     G = rob.gravload(q)  */
    /*      */
    /*   Description::  */
    /*     Given a full set of joint variables this function computes the  */
    /*     configuration dependent vector of gravitational load forces/torques.  */
    /*      */
    /*   Input::  */
    /*     rob: robot object of Quantec Ultra SE 125 specific class  */
    /*     q:  6-element vector of generalized  */
    /*          coordinates  */
    /*     Angles have to be given in radians!  */
    /*      */
    /*   Output::  */
    /*     G:  [6x1] vector of gravitational load forces/torques  */
    /*      */
    /*   Example::  */
    /*     ---  */
    /*      */
    /*   Known Bugs::  */
    /*     ---  */
    /*      */
    /*   TODO::  */
    /*     ---  */
    /*      */
    /*   References::  */
    /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
    /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
    /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
    /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
    /*      */
    /*   Authors::  */
    /*     This is an autogenerated function!  */
    /*     Code generator written by:  */
    /*     Joern Malzahn  */
    /*     2012 RST, Technische Universitaet Dortmund, Germany  */
    /*     http://www.rst.e-technik.tu-dortmund.de  */
    /*      */
    /*   See also inertia. */
    /*      */
    /*  Copyright (C) 1993-2021, by Peter I. Corke  */
    /*  Copyright (C) 2012-2021, by Joern Malzahn  */
    /*   */
    /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
    /*   */
    /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
    /*  it under the terms of the GNU Lesser General Public License as published by  */
    /*  the Free Software Foundation, either version 3 of the License, or  */
    /*  (at your option) any later version.  */
    /*    */
    /*  RTB is distributed in the hope that it will be useful,  */
    /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
    /*  GNU Lesser General Public License for more details.  */
    /*    */
    /*  You should have received a copy of the GNU Leser General Public License  */
    /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
    /*   */
    /*  http://www.petercorke.com  */
    /*   */
    /*  The code generation module emerged during the work on a project funded by  */
    /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
    /*  acknowledge the financial support.  */
    /*  Bugfix */
    /*   In some versions the symbolic toolbox writes the constant $pi$ in */
    /*   capital letters. This way autogenerated functions might not work properly. */
    /*   To fix this issue a local variable is introduced: */
    /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
    /*     02-Mar-2021 15:15:12 */
    t2 = muDoubleScalarCos(q_global[1]);
    t3 = muDoubleScalarCos(q_global[2]);
    t4 = muDoubleScalarCos(q_global[3]);
    t5 = muDoubleScalarCos(q_global[4]);
    t6 = muDoubleScalarSin(q_global[1]);
    t7 = muDoubleScalarSin(q_global[2]);
    t8 = muDoubleScalarSin(q_global[3]);
    t9 = muDoubleScalarSin(q_global[4]);
    t10_tmp = t2 * t7;
    t10 = t10_tmp * t8 * 25.041006;
    t11_tmp = t3 * t6;
    t11 = t11_tmp * t8 * 25.041006;
    t13 = t6 * t7 * 2056.0500396;
    t15 = t10_tmp * 108.2187207;
    t16 = t11_tmp * 108.2187207;
    t18 = t5 * t6 * t7 * 452.8427454;
    t20 = t2 * t4 * t7 * t9 * 452.8427454;
    t21 = t3 * t4 * t6 * t9 * 452.8427454;
    t7 = t2 * t3;
    t14 = -(t7 * 2056.0500396);
    t3 = -(t7 * t5 * 452.8427454);
    G_calc[0] = 0.0;
    G_calc[1] = ((((((((((t2 * -5023.5972102 - t6 * 3.3267672) + t10) + t11) +
                       t13) + t14) + t15) + t16) + t18) + t3) + t20) + t21;
    G_calc[2] = ((((((((t10 + t11) + t13) + t14) + t15) + t16) + t18) + t3) +
                 t20) + t21;
    G_calc[3] = muDoubleScalarCos(q_global[1] + q_global[2]) * (t4 *
      1.1495888408825929E+21 - t8 * t9 * 2.0789219362292281E+22) *
      -2.1782575743145571E-20;
    G_calc[4] = ((t4 * t18 + t10_tmp * t9 * 452.8427454) + t11_tmp * t9 *
                 452.8427454) - t7 * t4 * t5 * 452.8427454;
    G_calc[5] = 0.0;
    break;

   case 3:
    inertia_150(q_global, M_calc);
    coriolis_150(q_global, qd, C_calc);

    /*  GRAVLOAD - Computation of the configuration dependent vector of gravitational load forces/torques for Quantec Ultra SE 150  */
    /*  =========================================================================  */
    /*      */
    /*     G = gravload(rob,q)  */
    /*     G = rob.gravload(q)  */
    /*      */
    /*   Description::  */
    /*     Given a full set of joint variables this function computes the  */
    /*     configuration dependent vector of gravitational load forces/torques.  */
    /*      */
    /*   Input::  */
    /*     rob: robot object of Quantec Ultra SE 150 specific class  */
    /*     q:  6-element vector of generalized  */
    /*          coordinates  */
    /*     Angles have to be given in radians!  */
    /*      */
    /*   Output::  */
    /*     G:  [6x1] vector of gravitational load forces/torques  */
    /*      */
    /*   Example::  */
    /*     ---  */
    /*      */
    /*   Known Bugs::  */
    /*     ---  */
    /*      */
    /*   TODO::  */
    /*     ---  */
    /*      */
    /*   References::  */
    /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
    /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
    /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
    /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
    /*      */
    /*   Authors::  */
    /*     This is an autogenerated function!  */
    /*     Code generator written by:  */
    /*     Joern Malzahn  */
    /*     2012 RST, Technische Universitaet Dortmund, Germany  */
    /*     http://www.rst.e-technik.tu-dortmund.de  */
    /*      */
    /*   See also inertia. */
    /*      */
    /*  Copyright (C) 1993-2021, by Peter I. Corke  */
    /*  Copyright (C) 2012-2021, by Joern Malzahn  */
    /*   */
    /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
    /*   */
    /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
    /*  it under the terms of the GNU Lesser General Public License as published by  */
    /*  the Free Software Foundation, either version 3 of the License, or  */
    /*  (at your option) any later version.  */
    /*    */
    /*  RTB is distributed in the hope that it will be useful,  */
    /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
    /*  GNU Lesser General Public License for more details.  */
    /*    */
    /*  You should have received a copy of the GNU Leser General Public License  */
    /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
    /*   */
    /*  http://www.petercorke.com  */
    /*   */
    /*  The code generation module emerged during the work on a project funded by  */
    /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
    /*  acknowledge the financial support.  */
    /*  Bugfix */
    /*   In some versions the symbolic toolbox writes the constant $pi$ in */
    /*   capital letters. This way autogenerated functions might not work properly. */
    /*   To fix this issue a local variable is introduced: */
    /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
    /*     02-Mar-2021 15:33:35 */
    t2 = muDoubleScalarCos(q_global[1]);
    t3 = muDoubleScalarCos(q_global[2]);
    t4 = muDoubleScalarCos(q_global[3]);
    t5 = muDoubleScalarCos(q_global[4]);
    t6 = muDoubleScalarSin(q_global[1]);
    t7 = muDoubleScalarSin(q_global[2]);
    t8 = muDoubleScalarSin(q_global[3]);
    t9 = muDoubleScalarSin(q_global[4]);
    t10_tmp = t2 * t7;
    t10 = t10_tmp * t8 * 25.041006;
    t11_tmp = t3 * t6;
    t11 = t11_tmp * t8 * 25.041006;
    t13 = t6 * t7 * 2301.3000396;
    t14 = t10_tmp * 118.2739707;
    t15 = t11_tmp * 118.2739707;
    t18 = t5 * t6 * t7 * 536.2277454;
    t20 = t2 * t4 * t7 * t9 * 536.2277454;
    t21 = t3 * t4 * t6 * t9 * 536.2277454;
    t7 = t2 * t3;
    t16 = -(t7 * 2301.3000396);
    t3 = -(t7 * t5 * 536.2277454);
    G_calc[0] = 0.0;
    G_calc[1] = ((((((((((t2 * -5305.6347102 - t6 * 3.3267672) + t10) + t11) +
                       t13) + t14) + t15) + t16) + t18) + t3) + t20) + t21;
    G_calc[2] = ((((((((t10 + t11) + t13) + t14) + t15) + t16) + t18) + t3) +
                 t20) + t21;
    G_calc[3] = muDoubleScalarCos(q_global[1] + q_global[2]) * (t4 *
      2.873972102206482E+20 - t8 * t9 * 6.1543197613893E+21) *
      -8.7130302972582285E-20;
    G_calc[4] = ((t4 * t18 + t10_tmp * t9 * 536.2277454) + t11_tmp * t9 *
                 536.2277454) - t7 * t4 * t5 * 536.2277454;
    G_calc[5] = 0.0;
    break;

   case 4:
    inertia_175(q_global, M_calc);
    coriolis_175(q_global, qd, C_calc);

    /*  GRAVLOAD - Computation of the configuration dependent vector of gravitational load forces/torques for Quantec Ultra SE 175  */
    /*  =========================================================================  */
    /*      */
    /*     G = gravload(rob,q)  */
    /*     G = rob.gravload(q)  */
    /*      */
    /*   Description::  */
    /*     Given a full set of joint variables this function computes the  */
    /*     configuration dependent vector of gravitational load forces/torques.  */
    /*      */
    /*   Input::  */
    /*     rob: robot object of Quantec Ultra SE 175 specific class  */
    /*     q:  6-element vector of generalized  */
    /*          coordinates  */
    /*     Angles have to be given in radians!  */
    /*      */
    /*   Output::  */
    /*     G:  [6x1] vector of gravitational load forces/torques  */
    /*      */
    /*   Example::  */
    /*     ---  */
    /*      */
    /*   Known Bugs::  */
    /*     ---  */
    /*      */
    /*   TODO::  */
    /*     ---  */
    /*      */
    /*   References::  */
    /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
    /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
    /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
    /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
    /*      */
    /*   Authors::  */
    /*     This is an autogenerated function!  */
    /*     Code generator written by:  */
    /*     Joern Malzahn  */
    /*     2012 RST, Technische Universitaet Dortmund, Germany  */
    /*     http://www.rst.e-technik.tu-dortmund.de  */
    /*      */
    /*   See also inertia. */
    /*      */
    /*  Copyright (C) 1993-2021, by Peter I. Corke  */
    /*  Copyright (C) 2012-2021, by Joern Malzahn  */
    /*   */
    /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
    /*   */
    /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
    /*  it under the terms of the GNU Lesser General Public License as published by  */
    /*  the Free Software Foundation, either version 3 of the License, or  */
    /*  (at your option) any later version.  */
    /*    */
    /*  RTB is distributed in the hope that it will be useful,  */
    /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
    /*  GNU Lesser General Public License for more details.  */
    /*    */
    /*  You should have received a copy of the GNU Leser General Public License  */
    /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
    /*   */
    /*  http://www.petercorke.com  */
    /*   */
    /*  The code generation module emerged during the work on a project funded by  */
    /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
    /*  acknowledge the financial support.  */
    /*  Bugfix */
    /*   In some versions the symbolic toolbox writes the constant $pi$ in */
    /*   capital letters. This way autogenerated functions might not work properly. */
    /*   To fix this issue a local variable is introduced: */
    /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
    /*     02-Mar-2021 16:05:41 */
    t2 = muDoubleScalarCos(q_global[1]);
    t3 = muDoubleScalarCos(q_global[2]);
    t4 = muDoubleScalarCos(q_global[3]);
    t5 = muDoubleScalarCos(q_global[4]);
    t6 = muDoubleScalarSin(q_global[1]);
    t7 = muDoubleScalarSin(q_global[2]);
    t8 = muDoubleScalarSin(q_global[3]);
    t9 = muDoubleScalarSin(q_global[4]);
    t10_tmp = t2 * t7;
    t10 = t10_tmp * t8 * 25.041006;
    t11_tmp = t3 * t6;
    t11 = t11_tmp * t8 * 25.041006;
    t13 = t6 * t7 * 2546.5500396;
    t14 = t10_tmp * 128.3292207;
    t15 = t11_tmp * 128.3292207;
    t18 = t5 * t6 * t7 * 619.6127454;
    t20 = t2 * t4 * t7 * t9 * 619.6127454;
    t21 = t3 * t4 * t6 * t9 * 619.6127454;
    t7 = t2 * t3;
    t16 = -(t7 * 2546.5500396);
    t3 = -(t7 * t5 * 619.6127454);
    G_calc[0] = 0.0;
    G_calc[1] = ((((((((((t2 * -5587.6722102 - t6 * 3.3267672) + t10) + t11) +
                       t13) + t14) + t15) + t16) + t18) + t3) + t20) + t21;
    G_calc[2] = ((((((((t10 + t11) + t13) + t14) + t15) + t16) + t18) + t3) +
                 t20) + t21;
    G_calc[3] = muDoubleScalarCos(q_global[1] + q_global[2]) * (t4 * 127630.0 -
      t8 * t9 * 3.158067E+6) * -0.0001962;
    G_calc[4] = ((t4 * t18 + t10_tmp * t9 * 619.6127454) + t11_tmp * t9 *
                 619.6127454) - t7 * t4 * t5 * 619.6127454;
    G_calc[5] = 0.0;
    break;

   case 5:
    inertia_200(q_global, M_calc);
    coriolis_200(q_global, qd, C_calc);

    /*  GRAVLOAD - Computation of the configuration dependent vector of gravitational load forces/torques for Quantec Ultra SE 200  */
    /*  =========================================================================  */
    /*      */
    /*     G = gravload(rob,q)  */
    /*     G = rob.gravload(q)  */
    /*      */
    /*   Description::  */
    /*     Given a full set of joint variables this function computes the  */
    /*     configuration dependent vector of gravitational load forces/torques.  */
    /*      */
    /*   Input::  */
    /*     rob: robot object of Quantec Ultra SE 200 specific class  */
    /*     q:  6-element vector of generalized  */
    /*          coordinates  */
    /*     Angles have to be given in radians!  */
    /*      */
    /*   Output::  */
    /*     G:  [6x1] vector of gravitational load forces/torques  */
    /*      */
    /*   Example::  */
    /*     ---  */
    /*      */
    /*   Known Bugs::  */
    /*     ---  */
    /*      */
    /*   TODO::  */
    /*     ---  */
    /*      */
    /*   References::  */
    /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
    /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
    /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
    /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
    /*      */
    /*   Authors::  */
    /*     This is an autogenerated function!  */
    /*     Code generator written by:  */
    /*     Joern Malzahn  */
    /*     2012 RST, Technische Universitaet Dortmund, Germany  */
    /*     http://www.rst.e-technik.tu-dortmund.de  */
    /*      */
    /*   See also inertia. */
    /*      */
    /*  Copyright (C) 1993-2021, by Peter I. Corke  */
    /*  Copyright (C) 2012-2021, by Joern Malzahn  */
    /*   */
    /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
    /*   */
    /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
    /*  it under the terms of the GNU Lesser General Public License as published by  */
    /*  the Free Software Foundation, either version 3 of the License, or  */
    /*  (at your option) any later version.  */
    /*    */
    /*  RTB is distributed in the hope that it will be useful,  */
    /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
    /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
    /*  GNU Lesser General Public License for more details.  */
    /*    */
    /*  You should have received a copy of the GNU Leser General Public License  */
    /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
    /*   */
    /*  http://www.petercorke.com  */
    /*   */
    /*  The code generation module emerged during the work on a project funded by  */
    /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
    /*  acknowledge the financial support.  */
    /*  Bugfix */
    /*   In some versions the symbolic toolbox writes the constant $pi$ in */
    /*   capital letters. This way autogenerated functions might not work properly. */
    /*   To fix this issue a local variable is introduced: */
    /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
    /*     02-Mar-2021 16:27:24 */
    t2 = muDoubleScalarCos(q_global[1]);
    t3 = muDoubleScalarCos(q_global[2]);
    t4 = muDoubleScalarCos(q_global[3]);
    t5 = muDoubleScalarCos(q_global[4]);
    t6 = muDoubleScalarSin(q_global[1]);
    t7 = muDoubleScalarSin(q_global[2]);
    t8 = muDoubleScalarSin(q_global[3]);
    t9 = muDoubleScalarSin(q_global[4]);
    t10_tmp = t2 * t7;
    t10 = t10_tmp * t8 * 25.041006;
    t11_tmp = t3 * t6;
    t11 = t11_tmp * t8 * 25.041006;
    t13 = t6 * t7 * 2791.8000396;
    t14 = t10_tmp * 138.3844707;
    t15 = t11_tmp * 138.3844707;
    t18 = t5 * t6 * t7 * 702.9977454;
    t20 = t2 * t4 * t7 * t9 * 702.9977454;
    t21 = t3 * t4 * t6 * t9 * 702.9977454;
    t7 = t2 * t3;
    t16 = -(t7 * 2791.8000396);
    t3 = -(t7 * t5 * 702.9977454);
    G_calc[0] = 0.0;
    G_calc[1] = ((((((((((t2 * -5869.7097102 - t6 * 3.3267672) + t10) + t11) +
                       t13) + t14) + t15) + t16) + t18) + t3) + t20) + t21;
    G_calc[2] = ((((((((t10 + t11) + t13) + t14) + t15) + t16) + t18) + t3) +
                 t20) + t21;
    G_calc[3] = muDoubleScalarCos(q_global[1] + q_global[2]) * (t4 *
      5.747944204412964E+20 - t8 * t9 * 1.6136699206043521E+22) *
      -4.3565151486291142E-20;
    G_calc[4] = ((t4 * t18 + t10_tmp * t9 * 702.9977454) + t11_tmp * t9 *
                 702.9977454) - t7 * t4 * t5 * 702.9977454;
    G_calc[5] = 0.0;
    break;

   default:
    /*  for code generation */
    memset(&M_calc[0], 0, 36U * sizeof(real_T));
    for (i = 0; i < 6; i++) {
      M_calc[i + 6 * i] = 1.0;
    }

    memcpy(&C_calc[0], &M_calc[0], 36U * sizeof(real_T));
    for (i = 0; i < 6; i++) {
      G_calc[i] = 0.0;
    }
    break;
  }

  st.site = &u_emlrtRSI;
  mpower(&st, M_calc, M_inverse_calc);
}

void robot_dynamics(const emlrtStack *sp, const real_T q[6], const real_T qd[6],
                    real_T m_pay, real_T M_inverse[36], real_T C[36], real_T G[6])
{
  static const real_T qs[6] = { 0.0, -1.5707963267948966, 1.5707963267948966,
    0.0, 0.0, 0.0 };

  emlrtStack st;
  real_T C_low[36];
  real_T M_high[36];
  real_T M_low[36];
  real_T G_low[6];
  real_T q_global[6];
  real_T d;
  real_T m_pay_high;
  real_T m_pay_low;
  real_T unnamed_idx_0;
  int32_T i;
  st.prev = sp;
  st.tls = sp->tls;

  /*  transfer from relative to global coordiantes */
  for (i = 0; i < 6; i++) {
    q_global[i] = q[i] + qs[i];
  }

  /*  enforce bounds */
  unnamed_idx_0 = m_pay;
  if (m_pay < 1.0) {
    unnamed_idx_0 = 1.0;
  }

  if (unnamed_idx_0 > 5.0) {
    unnamed_idx_0 = 5.0;
  }

  m_pay_low = muDoubleScalarFloor(unnamed_idx_0);
  m_pay_high = muDoubleScalarCeil(unnamed_idx_0);
  st.site = &h_emlrtRSI;
  calc_model(&st, m_pay_high, q_global, qd, M_inverse, C, G, M_high);

  /*  if m_pay is already an integer, then m_pay = m_pay_low = m_pay_high */
  /*  and the model does not need to be interpo */
  if (!(m_pay_low == m_pay_high)) {
    st.site = &i_emlrtRSI;
    calc_model(&st, m_pay_low, q_global, qd, M_high, C_low, G_low, M_low);
    d = unnamed_idx_0 - m_pay_low;
    unnamed_idx_0 = m_pay_high - m_pay_low;
    for (i = 0; i < 36; i++) {
      m_pay_low = M_high[i];
      M_inverse[i] = m_pay_low + (M_inverse[i] - m_pay_low) * d / unnamed_idx_0;
      m_pay_low = C_low[i];
      C[i] = m_pay_low + (C[i] - m_pay_low) * d / unnamed_idx_0;
    }

    for (i = 0; i < 6; i++) {
      m_pay_low = G_low[i];
      G[i] = m_pay_low + (G[i] - m_pay_low) * d / unnamed_idx_0;
    }
  }

  /*  hydraulic counter weight */
  /*  Calculate the torque on joint 2 caused by the hydraulic weight counterbalance */
  /*  measured data from robot for comparison */
  /*  p_data = 1e5*[170, 167, 164, 162, 164, 170, 180, 190, 200]; % pressure in bar */
  /*  a_data =  -1*[120, 110, 100, 90,  80,   70,  60,  50,  40]; % angle in deg */
  /*  press = interp1(a_data,p_data,angle_ax_2,'linear','extrap'); */
  /*  Input:   angle_ax_2 - angle link 2 in deg  */
  /*  Output:  tau - torque acting on link 2 resulting from hydraulic spring */
  /*           press - pressure in hydraulic spring in Pa */
  /*  Parameters for Bucher Hydraulics Bladder Accumulator Piston 0000179517 GA12 24967030000049.02.1 */
  /*  Geometric Parameters Anchor Points (measured on robot CAD-model) */
  /*  direct distance between anchor point of spring on link 1 to axis 2 */
  /*  distance anchor point of spring on link 2 to axis 2 */
  /*  lenght of spring in fully retracted position */
  /*  Geometric Parameters Piston */
  /*  in m */
  /*  in m, approximated using Website of Bucher, DIN EN 22553 and the width of welding seam on piston as well as taking the max ammount of force needed) */
  /*  in m^2 */
  /*  % fluid parameters Nitrogen */
  /*  in kg */
  /*  in m^3 */
  /*  compressibility factor nitrogen at pressure of 176 bar and T = 295.5 K (at 328 K: Z = 1.02986) */
  /*  max operating temperature of the robot: T_max = 328 K */
  /*  Geometry calculation */
  /*  set angle alpha to deviation from vertical pose -5° */
  /*  set deviation from vertical pose -5° (due to mount of spring, the vertical pose is not at minimum force. That is at -95°) */
  /*  calculate displacement of piston rod dl in m with cosine-rule */
  unnamed_idx_0 = muDoubleScalarSqrt(0.68000000000000016 - 0.32000000000000006 *
    muDoubleScalarCos(q_global[1] + 1.6580627893946132));

  /*  calculate lever arm h in m */
  /*  utilizing sine-rule */
  /*  calcuate pressure */
  /*  calculate torque */
  G[1] += muDoubleScalarSin(q_global[1] + 1.6580627893946132) * 0.8 * 0.2 /
    ((unnamed_idx_0 - 0.60000000000000009) + 0.60000000000000009) *
    (15633.500736000002 / (0.00096 - (unnamed_idx_0 - 0.60000000000000009) *
      0.0016689710972195777)) * 0.0016689710972195777;
}

/* End of code generation (robot_dynamics.c) */
