/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * inertia_150.c
 *
 * Code generation for function 'inertia_150'
 *
 */

/* Include files */
#include "inertia_150.h"
#include "mwmathutil.h"
#include "rt_nonfinite.h"
#include "runge_kutta_4.h"
#include "runge_kutta_4_data.h"
#include <string.h>

/* Function Definitions */
void inertia_150(const real_T q[6], real_T b_I[36])
{
  real_T t2_tmp;
  real_T t3_tmp;
  real_T t4_tmp;
  real_T t5_tmp;
  real_T t6_tmp;
  real_T t7_tmp;
  real_T t8_tmp;
  real_T t9_tmp;
  real_T t10;
  real_T t11;
  real_T t12_tmp;
  real_T t13_tmp;
  real_T t18_tmp_tmp_tmp;
  real_T t18_tmp;
  real_T b_t18_tmp;
  real_T t18;
  real_T t19_tmp_tmp;
  real_T t19_tmp;
  real_T t19;
  real_T t21;
  real_T t22_tmp_tmp_tmp;
  real_T t22_tmp;
  real_T t22;
  real_T t23_tmp_tmp;
  real_T t23;
  real_T t24_tmp_tmp;
  real_T t24;
  real_T t28_tmp;
  real_T t28;
  real_T t29_tmp_tmp;
  real_T t29;
  real_T t34_tmp_tmp;
  real_T t34_tmp;
  real_T b_t34_tmp;
  real_T t34;
  real_T t35_tmp_tmp;
  real_T t71;
  real_T t35_tmp;
  real_T t35;
  real_T t41_tmp_tmp;
  real_T t17;
  real_T t41;
  real_T t42_tmp;
  real_T t42;
  real_T t43_tmp;
  real_T t43;
  real_T t44_tmp;
  real_T t44;
  real_T t46;
  real_T t47;
  real_T t27;
  real_T t48;
  real_T t49_tmp;
  real_T t49;
  real_T t50;
  real_T t51;
  real_T t56;
  real_T t59;
  real_T t61_tmp;
  real_T b_t61_tmp;
  real_T t61;
  real_T t62_tmp;
  real_T b_t62_tmp;
  real_T t62;
  real_T t65;
  real_T t26;
  real_T t66;
  real_T t68_tmp_tmp;
  real_T t68_tmp;
  real_T b_t68_tmp;
  real_T t68;
  real_T t69_tmp_tmp;
  real_T t69_tmp;
  real_T b_t69_tmp;
  real_T t69;
  real_T t14;
  real_T t15;
  real_T t30;
  real_T t31;
  real_T t38;
  real_T t39;
  real_T t57;
  real_T t58;
  real_T t70;
  real_T d;
  real_T I_tmp;
  real_T b_I_tmp;
  real_T c_I_tmp;
  real_T t24_tmp;
  real_T d1;
  real_T d2;
  real_T d3;
  real_T d4;
  real_T d5;
  real_T d6;
  real_T d7;
  real_T d8;
  real_T d9;
  real_T d10;
  real_T d11;
  real_T d12;
  real_T d13;
  real_T d14;
  real_T d15;
  real_T d16;
  real_T d17;
  real_T d18;
  real_T d19;
  real_T d20;
  real_T d21;
  real_T d22;
  real_T d23;
  real_T d_I_tmp;
  real_T e_I_tmp;
  real_T f_I_tmp;
  real_T g_I_tmp;
  real_T h_I_tmp;
  real_T i_I_tmp;
  real_T j_I_tmp;
  real_T k_I_tmp;
  real_T l_I_tmp;
  real_T m_I_tmp;
  real_T n_I_tmp;
  real_T o_I_tmp;
  real_T p_I_tmp;
  real_T q_I_tmp;
  int32_T i;

  /*  INERTIA - Inertia matrix for the Quantec Ultra SE 150 arm.  */
  /*  =========================================================================  */
  /*      */
  /*     I = inertia(rob,q)  */
  /*     I = rob.inertia(q)  */
  /*      */
  /*   Description::  */
  /*     Given a full set of joint variables the function computes the  */
  /*     inertia Matrix of the robot.  */
  /*      */
  /*   Input::  */
  /*     rob: robot object of Quantec Ultra SE 150 specific class  */
  /*     q:  6-element vector of generalized  */
  /*          coordinates  */
  /*     Angles have to be given in radians!  */
  /*      */
  /*   Output::  */
  /*     I:  [6x6] inertia matrix  */
  /*      */
  /*   Example::  */
  /*     ---  */
  /*      */
  /*   Known Bugs::  */
  /*     ---  */
  /*      */
  /*   TODO::  */
  /*     ---  */
  /*      */
  /*   References::  */
  /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
  /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
  /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
  /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
  /*      */
  /*   Authors::  */
  /*     This is an autogenerated function!  */
  /*     Code generator written by:  */
  /*     Joern Malzahn  */
  /*     2012 RST, Technische Universitaet Dortmund, Germany  */
  /*     http://www.rst.e-technik.tu-dortmund.de  */
  /*      */
  /*   See also coriolis. */
  /*      */
  /*  Copyright (C) 1993-2021, by Peter I. Corke  */
  /*  Copyright (C) 2012-2021, by Joern Malzahn  */
  /*   */
  /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
  /*   */
  /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
  /*  it under the terms of the GNU Lesser General Public License as published by  */
  /*  the Free Software Foundation, either version 3 of the License, or  */
  /*  (at your option) any later version.  */
  /*    */
  /*  RTB is distributed in the hope that it will be useful,  */
  /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
  /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
  /*  GNU Lesser General Public License for more details.  */
  /*    */
  /*  You should have received a copy of the GNU Leser General Public License  */
  /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
  /*   */
  /*  http://www.petercorke.com  */
  /*   */
  /*  The code generation module emerged during the work on a project funded by  */
  /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
  /*  acknowledge the financial support.  */
  memset(&b_I[0], 0, 36U * sizeof(real_T));

  /*  INERTIA_ROW_1 - Computation of the robot specific inertia matrix row for corresponding to joint 1 of 6.  */
  /*  =========================================================================  */
  /*      */
  /*     Irow = inertia_row_1(rob,q)  */
  /*     Irow = rob.inertia_row_1(q)  */
  /*      */
  /*   Description::  */
  /*     Given a full set of joint variables this function computes the  */
  /*     inertia matrix row number 1 of 6 for Quantec Ultra SE 150.  */
  /*      */
  /*   Input::  */
  /*     rob: robot object of Quantec Ultra SE 150 specific class  */
  /*     q:  6-element vector of generalized  */
  /*          coordinates  */
  /*     Angles have to be given in radians!  */
  /*      */
  /*   Output::  */
  /*     Irow:  [1x6] row of the robot inertia matrix  */
  /*      */
  /*   Example::  */
  /*     ---  */
  /*      */
  /*   Known Bugs::  */
  /*     ---  */
  /*      */
  /*   TODO::  */
  /*     ---  */
  /*      */
  /*   References::  */
  /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
  /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
  /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
  /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
  /*      */
  /*   Authors::  */
  /*     This is an autogenerated function!  */
  /*     Code generator written by:  */
  /*     Joern Malzahn  */
  /*     2012 RST, Technische Universitaet Dortmund, Germany  */
  /*     http://www.rst.e-technik.tu-dortmund.de  */
  /*      */
  /*   See also coriolis. */
  /*      */
  /*  Copyright (C) 1993-2021, by Peter I. Corke  */
  /*  Copyright (C) 2012-2021, by Joern Malzahn  */
  /*   */
  /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
  /*   */
  /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
  /*  it under the terms of the GNU Lesser General Public License as published by  */
  /*  the Free Software Foundation, either version 3 of the License, or  */
  /*  (at your option) any later version.  */
  /*    */
  /*  RTB is distributed in the hope that it will be useful,  */
  /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
  /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
  /*  GNU Lesser General Public License for more details.  */
  /*    */
  /*  You should have received a copy of the GNU Leser General Public License  */
  /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
  /*   */
  /*  http://www.petercorke.com  */
  /*   */
  /*  The code generation module emerged during the work on a project funded by  */
  /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
  /*  acknowledge the financial support.  */
  /*  Bugfix */
  /*   In some versions the symbolic toolbox writes the constant $pi$ in */
  /*   capital letters. This way autogenerated functions might not work properly. */
  /*   To fix this issue a local variable is introduced: */
  /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
  /*     02-Mar-2021 15:33:20 */
  t2_tmp = muDoubleScalarCos(q[1]);
  t3_tmp = muDoubleScalarCos(q[2]);
  t4_tmp = muDoubleScalarCos(q[3]);
  t5_tmp = muDoubleScalarCos(q[4]);
  t6_tmp = muDoubleScalarSin(q[1]);
  t7_tmp = muDoubleScalarSin(q[2]);
  t8_tmp = muDoubleScalarSin(q[3]);
  t9_tmp = muDoubleScalarSin(q[4]);
  t10 = t2_tmp * t2_tmp;
  t11 = t3_tmp * t3_tmp;
  t12_tmp = t4_tmp * t4_tmp;
  t13_tmp = t5_tmp * t5_tmp;
  t18_tmp_tmp_tmp = t2_tmp * t3_tmp;
  t18_tmp = t18_tmp_tmp_tmp * t4_tmp;
  b_t18_tmp = t18_tmp * t5_tmp;
  t18 = b_t18_tmp * t8_tmp * t9_tmp * 0.00024;
  t19_tmp_tmp = t4_tmp * t5_tmp;
  t19_tmp = t19_tmp_tmp * t6_tmp * t7_tmp;
  t19 = t19_tmp * t8_tmp * t9_tmp * 0.00024;
  t21 = t18_tmp * 0.1046566;
  t22_tmp_tmp_tmp = t4_tmp * t6_tmp;
  t22_tmp = t22_tmp_tmp_tmp * t7_tmp;
  t22 = t22_tmp * 0.1046566;
  t23_tmp_tmp = t2_tmp * t7_tmp;
  t23 = t23_tmp_tmp * 0.75031128;
  t24_tmp_tmp = t3_tmp * t6_tmp;
  t24 = t24_tmp_tmp * 0.75031128;
  t28_tmp = t18_tmp_tmp_tmp * t5_tmp;
  t28 = t28_tmp * 4.0E-6;
  t29_tmp_tmp = t5_tmp * t6_tmp * t7_tmp;
  t29 = t29_tmp_tmp * 4.0E-6;
  t34_tmp_tmp = t2_tmp * t4_tmp;
  t34_tmp = t34_tmp_tmp * t7_tmp;
  b_t34_tmp = t34_tmp * t9_tmp;
  t34 = b_t34_tmp * 4.0E-6;
  t35_tmp_tmp = t3_tmp * t4_tmp;
  t71 = t35_tmp_tmp * t6_tmp;
  t35_tmp = t71 * t9_tmp;
  t35 = t35_tmp * 4.0E-6;
  t41_tmp_tmp = t6_tmp * t7_tmp;
  t17 = t41_tmp_tmp * t9_tmp;
  t41 = t17 * 0.0421722;
  t42_tmp = t23_tmp_tmp * t8_tmp;
  t42 = t42_tmp * t9_tmp * 54.66134;
  t43_tmp = t24_tmp_tmp * t8_tmp;
  t43 = t43_tmp * t9_tmp * 54.66134;
  t44_tmp = t18_tmp_tmp_tmp * t9_tmp;
  t44 = t44_tmp * 0.0421722;
  t46 = t42_tmp * 0.000116;
  t47 = t43_tmp * 0.000116;
  t27 = t34_tmp_tmp * t5_tmp;
  t48 = t27 * t7_tmp * 0.0421722;
  t49_tmp = t35_tmp_tmp * t5_tmp;
  t49 = t49_tmp * t6_tmp * 0.0421722;
  t50 = t34_tmp * 2.5327982;
  t51 = t71 * 2.5327982;
  t56 = t41_tmp_tmp * 0.16200394;
  t59 = t18_tmp_tmp_tmp * 0.16200394;
  t61_tmp = t18_tmp_tmp_tmp * t8_tmp;
  b_t61_tmp = t61_tmp * t9_tmp;
  t61 = b_t61_tmp * 2.24111494;
  t62_tmp = t41_tmp_tmp * t8_tmp;
  b_t62_tmp = t62_tmp * t9_tmp;
  t62 = b_t62_tmp * 2.24111494;
  t71 = t18_tmp * t8_tmp;
  t65 = t71 * 17.4000966011372;
  t26 = t22_tmp * t8_tmp;
  t66 = t26 * 17.4000966011372;
  t68_tmp_tmp = t2_tmp * t5_tmp;
  t68_tmp = t68_tmp_tmp * t7_tmp;
  b_t68_tmp = t68_tmp * t8_tmp;
  t68 = b_t68_tmp * t9_tmp * 17.6523104011372;
  t69_tmp_tmp = t3_tmp * t5_tmp;
  t69_tmp = t69_tmp_tmp * t6_tmp;
  b_t69_tmp = t69_tmp * t8_tmp;
  t69 = b_t69_tmp * t9_tmp * 17.6523104011372;
  t14 = t42_tmp * t13_tmp * 0.00024;
  t15 = t43_tmp * t13_tmp * 0.00024;
  t30 = t18_tmp_tmp_tmp * t12_tmp * 5.4E-5;
  t31 = t41_tmp_tmp * t12_tmp * 5.4E-5;
  t38 = t28_tmp * t12_tmp * 8.0E-6;
  t39 = t29_tmp_tmp * t12_tmp * 8.0E-6;
  t57 = t44_tmp * t12_tmp * 0.0843444;
  t58 = t17 * t12_tmp * 0.0843444;
  t70 = t71 * t13_tmp * 17.6523104011372;
  t71 = t26 * t13_tmp * 17.6523104011372;
  t17 = t5_tmp * t10;
  d = muDoubleScalarSin(q[3] * 2.0) * 2.7E-5;
  t26 = t8_tmp * t10;
  I_tmp = t2_tmp * t6_tmp;
  b_I_tmp = t3_tmp * t7_tmp;
  c_I_tmp = t4_tmp * t8_tmp;
  t24_tmp = t4_tmp * t9_tmp;
  d1 = t5_tmp * t9_tmp;
  t34_tmp = t10 * t11;
  t44_tmp = t10 * t12_tmp;
  d2 = t11 * t12_tmp;
  d3 = t18_tmp_tmp_tmp * t6_tmp;
  d4 = t68_tmp_tmp * t6_tmp;
  d5 = t34_tmp_tmp * t6_tmp;
  d6 = t35_tmp_tmp * t7_tmp;
  d7 = t69_tmp_tmp * t7_tmp;
  d8 = I_tmp * t8_tmp;
  d9 = b_I_tmp * t8_tmp;
  d10 = t19_tmp_tmp * t8_tmp;
  d11 = c_I_tmp * t9_tmp;
  d12 = c_I_tmp * t10;
  d13 = t24_tmp * t10;
  d14 = d1 * t10;
  d15 = d1 * t11;
  d16 = t34_tmp * t12_tmp;
  d17 = d3 * t7_tmp;
  d18 = d5 * t9_tmp;
  d19 = d4 * t8_tmp;
  d20 = d6 * t9_tmp;
  d21 = d5 * t11;
  d22 = d7 * t8_tmp;
  d23 = d6 * t10;
  d_I_tmp = d9 * t9_tmp;
  e_I_tmp = d10 * t10;
  f_I_tmp = d11 * t10;
  g_I_tmp = d14 * t11;
  h_I_tmp = t18_tmp * t6_tmp;
  i_I_tmp = h_I_tmp * t7_tmp;
  j_I_tmp = t28_tmp * t6_tmp * t7_tmp;
  k_I_tmp = t27 * t6_tmp * t9_tmp;
  l_I_tmp = t49_tmp * t7_tmp * t9_tmp;
  m_I_tmp = d17 * t12_tmp;
  n_I_tmp = i_I_tmp * t8_tmp;
  o_I_tmp = j_I_tmp * t9_tmp;
  p_I_tmp = t7_tmp * t8_tmp;
  q_I_tmp = t4_tmp * t7_tmp * t9_tmp;
  b_I[0] =
    (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
    (((((((((((((((((((((((((((((((((((t2_tmp * 378.587594 + t5_tmp * 109.32268)
    + t6_tmp * 0.237384) + t10 * 368.22285597) - t11 * 229.08869863) - t12_tmp *
    17.4000966011372) + muDoubleScalarSin(q[1] * 2.0) * 9.9517942) +
    muDoubleScalarSin(q[2] * 2.0) * 9.37219628) - d) + t18_tmp_tmp_tmp *
    164.211012) - t23_tmp_tmp * 8.439529) - t24_tmp_tmp * 8.439529) + t3_tmp *
    t10 * 539.550468) - t41_tmp_tmp * 164.211012) - t17 * 109.32268) - t5_tmp *
    t11 * 109.32268) - t7_tmp * t10 * 27.729881) + t26 * 0.2093132) + t8_tmp *
    t11 * 0.2093132) + t34_tmp * 458.17739726) + t44_tmp * 17.4000966011372) -
    t10 * t13_tmp * 17.6523104011372) + d2 * 17.4000966011372) - t11 * t13_tmp *
    17.6523104011372) + t12_tmp * t13_tmp * 17.6523104011372) + t28_tmp *
    38.262938) - d3 * 27.729881) + d5 * 0.000232) + d4 * 4.48222988) + d6 *
    0.000232) - I_tmp * t7_tmp * 539.550468) + d7 * 4.48222988) + d8 * 5.0655964)
    - t42_tmp * 1.78682) - t43_tmp * 1.78682) + d10 * 8.0E-6) + t69_tmp_tmp *
    t10 * 125.721082) + d9 * 5.0655964) - t29_tmp_tmp * 38.262938) - I_tmp * t11
    * 37.48878512) - b_I_tmp * t10 * 37.48878512) - d11 * 0.0843444) + d12 *
    5.4E-5) + c_I_tmp * t11 * 5.4E-5) + d13 * 4.48222988) + t24_tmp * t11 *
    4.48222988) - d14 * 0.00024) - d15 * 0.00024) - p_I_tmp * t10 * 5.87098) +
    d1 * t12_tmp * 0.00024) + t17 * t11 * 218.64536) - t26 * t11 * 0.4186264) -
    d16 * 34.800193202274407) + t34_tmp * t13_tmp * 35.304620802274407) -
    t44_tmp * t13_tmp * 17.6523104011372) - d2 * t13_tmp * 17.6523104011372) -
    d17 * 458.17739726) - d3 * t8_tmp * 5.87098) - d4 * t7_tmp * 125.721082) +
    d18 * 109.32268) + d19 * 0.0843444) - b_t34_tmp * 38.262938) - t35_tmp *
    38.262938) - d21 * 0.000464) + d20 * 109.32268) + d22 * 0.0843444) - d4 *
    t11 * 8.96445976) - d23 * 0.000464) - d5 * t13_tmp * 0.00048) + d8 * t9_tmp *
    8.0E-6) - d7 * t10 * 8.96445976) - d8 * t11 * 10.1311928) - t3_tmp * t4_tmp *
    t7_tmp * t13_tmp * 0.00048) + d_I_tmp * 8.0E-6) - e_I_tmp * 8.0E-6) - d9 *
    t10 * 10.1311928) - d10 * t11 * 8.0E-6) - q_I_tmp * t10 * 125.721082) +
    f_I_tmp * 0.0843444) + d11 * t11 * 0.0843444) - d12 * t11 * 0.000108) - d13 *
    t11 * 8.96445976) + g_I_tmp * 0.00048) - d14 * t12_tmp * 0.00024) - d15 *
    t12_tmp * 0.00024) + d16 * t13_tmp * 35.304620802274407) - j_I_tmp *
    218.64536) - h_I_tmp * t9_tmp * 125.721082) + d17 * t8_tmp * 0.4186264) +
    k_I_tmp * 35.304620802274407) + l_I_tmp * 35.304620802274407) + m_I_tmp *
    34.800193202274407) - d17 * t13_tmp * 35.304620802274407) - d18 * t11 *
    218.64536) - d19 * t11 * 0.1686888) - d20 * t10 * 218.64536) - d22 * t10 *
                     0.1686888) + d21 * t13_tmp * 0.00096) - t2_tmp * t6_tmp *
                   t8_tmp * t9_tmp * t11 * 1.6E-5) + d23 * t13_tmp * 0.00096) -
                 d_I_tmp * t10 * 1.6E-5) + e_I_tmp * t11 * 1.6E-5) - f_I_tmp *
               t11 * 0.1686888) + g_I_tmp * t12_tmp * 0.00048) + n_I_tmp *
             0.000108) + i_I_tmp * t9_tmp * 8.96445976) - o_I_tmp * 0.00048) -
          k_I_tmp * t11 * 70.609241604548814) - l_I_tmp * t10 *
         70.609241604548814) - m_I_tmp * t13_tmp * 35.304620802274407) -
       b_t18_tmp * t6_tmp * t7_tmp * t8_tmp * 1.6E-5) + n_I_tmp * t9_tmp *
      0.1686888) - o_I_tmp * t12_tmp * 0.00048) + 988.6861636941984;
  d_I_tmp = t2_tmp * 0.11686308 + t6_tmp * 18.25116472;
  e_I_tmp = t6_tmp * t8_tmp * t9_tmp * 62.860541;
  b_I[6] = (((((((((((((((((((((((((((((((((((((((d_I_tmp + -t14) + -t15) + t19)
    + -t18) + t22) + -t21) + -t23) + -t24) + t29) + t31) + -t28) + -t30) + -t34)
    + -t35) + t38) + -t39) + t42) + t43) + t44) + -t41) + t46) + t47) + -t48) +
    -t49) + -t50) + -t51) + t56) + t58) + -t57) + t61) + -t59) + -t62) + t65) +
                 -t66) + t68) + t69) + t71) + -t70) - t22_tmp_tmp_tmp * 2.93549)
    + e_I_tmp;
  b_I[12] = ((((((((((((((((((((((((((((((((((((-t14 + -t15) + t19) + -t18) +
    t22) + -t21) + -t23) + -t24) + t29) + t31) + -t28) + -t30) + -t34) + -t35) +
    t38) + -t39) + t42) + t43) + t44) + -t41) + t46) + t47) + -t48) + -t49) +
    -t50) + -t51) + t56) + t58) + -t57) + t61) + -t59) + -t62) + t65) + -t66) +
               t68) + t69) + t71) + -t70;
  f_I_tmp = t18_tmp * t9_tmp;
  g_I_tmp = t28_tmp * t8_tmp;
  h_I_tmp = t29_tmp_tmp * t8_tmp;
  i_I_tmp = t2_tmp * t8_tmp * 2.93549;
  b_I[18] = ((((((((((((((((((((((((((t8_tmp * 0.89341 - t23_tmp_tmp *
    18.3299492011372) - t24_tmp_tmp * 18.3299492011372) + i_I_tmp) + t24_tmp *
    19.131469) + t18_tmp * 0.000116) + t61_tmp * 2.5327982) + t34_tmp_tmp *
    t9_tmp * 62.860541) - t42_tmp * 0.1046566) - t43_tmp * 0.1046566) - t22_tmp *
    0.000116) - t62_tmp * 2.5327982) + t23_tmp_tmp * t13_tmp * 17.6523104011372)
    + t24_tmp_tmp * t13_tmp * 17.6523104011372) + f_I_tmp * 54.66134) + g_I_tmp *
                        0.0421722) - t18_tmp * t13_tmp * 0.00024) + b_t61_tmp *
                      4.0E-6) - b_t34_tmp * 2.24111494) - t35_tmp * 2.24111494)
                   + t68_tmp * t9_tmp * 0.00024) + t69_tmp * t9_tmp * 0.00024) -
                 t22_tmp * t9_tmp * 54.66134) - h_I_tmp * 0.0421722) + t22_tmp *
               t13_tmp * 0.00024) - b_t62_tmp * 4.0E-6) + b_t18_tmp * t9_tmp *
             17.6523104011372) - t19_tmp * t9_tmp * 17.6523104011372;
  j_I_tmp = t5_tmp * t8_tmp;
  b_I[24] = ((((((((((((((j_I_tmp * 19.131469 + t4_tmp * t28) + t4_tmp * t41) +
                        t61_tmp * 17.8563124011372) - t68_tmp * 0.0421722) -
                      t69_tmp * 0.0421722) + t68_tmp_tmp * t8_tmp * 62.860541) -
                    t23_tmp_tmp * t9_tmp * 4.0E-6) - t24_tmp_tmp * t9_tmp *
                   4.0E-6) - t62_tmp * 17.8563124011372) - f_I_tmp * 0.0421722)
                + g_I_tmp * 54.66134) - b_t68_tmp * 2.24111494) - b_t69_tmp *
              2.24111494) - t19_tmp * 4.0E-6) - h_I_tmp * 54.66134;
  b_I[30] = 0.0;

  /*  INERTIA_ROW_2 - Computation of the robot specific inertia matrix row for corresponding to joint 2 of 6.  */
  /*  =========================================================================  */
  /*      */
  /*     Irow = inertia_row_2(rob,q)  */
  /*     Irow = rob.inertia_row_2(q)  */
  /*      */
  /*   Description::  */
  /*     Given a full set of joint variables this function computes the  */
  /*     inertia matrix row number 2 of 6 for Quantec Ultra SE 150.  */
  /*      */
  /*   Input::  */
  /*     rob: robot object of Quantec Ultra SE 150 specific class  */
  /*     q:  6-element vector of generalized  */
  /*          coordinates  */
  /*     Angles have to be given in radians!  */
  /*      */
  /*   Output::  */
  /*     Irow:  [1x6] row of the robot inertia matrix  */
  /*      */
  /*   Example::  */
  /*     ---  */
  /*      */
  /*   Known Bugs::  */
  /*     ---  */
  /*      */
  /*   TODO::  */
  /*     ---  */
  /*      */
  /*   References::  */
  /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
  /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
  /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
  /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
  /*      */
  /*   Authors::  */
  /*     This is an autogenerated function!  */
  /*     Code generator written by:  */
  /*     Joern Malzahn  */
  /*     2012 RST, Technische Universitaet Dortmund, Germany  */
  /*     http://www.rst.e-technik.tu-dortmund.de  */
  /*      */
  /*   See also coriolis. */
  /*      */
  /*  Copyright (C) 1993-2021, by Peter I. Corke  */
  /*  Copyright (C) 2012-2021, by Joern Malzahn  */
  /*   */
  /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
  /*   */
  /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
  /*  it under the terms of the GNU Lesser General Public License as published by  */
  /*  the Free Software Foundation, either version 3 of the License, or  */
  /*  (at your option) any later version.  */
  /*    */
  /*  RTB is distributed in the hope that it will be useful,  */
  /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
  /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
  /*  GNU Lesser General Public License for more details.  */
  /*    */
  /*  You should have received a copy of the GNU Leser General Public License  */
  /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
  /*   */
  /*  http://www.petercorke.com  */
  /*   */
  /*  The code generation module emerged during the work on a project funded by  */
  /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
  /*  acknowledge the financial support.  */
  /*  Bugfix */
  /*   In some versions the symbolic toolbox writes the constant $pi$ in */
  /*   capital letters. This way autogenerated functions might not work properly. */
  /*   To fix this issue a local variable is introduced: */
  /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
  /*     02-Mar-2021 15:33:23 */
  t18 = t8_tmp * 0.2093132;
  t21 = t5_tmp * 109.32268;
  t22 = t19_tmp_tmp * t8_tmp * 8.0E-6;
  t24 = t24_tmp * 4.48222988;
  t71 = t4_tmp * t8_tmp * t9_tmp * 0.0843444;
  t44_tmp = muDoubleScalarSin(q[4] * 2.0) * 0.00012;
  t17 = d1 * t12_tmp * 0.00024;
  t26 = t12_tmp * 17.4000966011372;
  t27 = t13_tmp * 17.6523104011372;
  t29 = t12_tmp * t13_tmp * -17.6523104011372;
  f_I_tmp = t18_tmp_tmp_tmp * t4_tmp;
  g_I_tmp = t18_tmp_tmp_tmp * t5_tmp;
  h_I_tmp = t34_tmp_tmp * t7_tmp;
  k_I_tmp = t35_tmp_tmp * t6_tmp;
  l_I_tmp = t22_tmp_tmp_tmp * t7_tmp;
  m_I_tmp = t18_tmp_tmp_tmp * t9_tmp;
  n_I_tmp = t23_tmp_tmp * t8_tmp;
  o_I_tmp = t24_tmp_tmp * t8_tmp;
  t49_tmp = t41_tmp_tmp * t9_tmp;
  I_tmp = f_I_tmp * t8_tmp;
  b_I_tmp = l_I_tmp * t8_tmp;
  c_I_tmp = t35_tmp_tmp * t5_tmp;
  b_I[1] = (((((((((((((((((((((((((((((((((((((((d_I_tmp - t18_tmp_tmp_tmp *
    0.16200394) - t23_tmp_tmp * 0.75031128) - t24_tmp_tmp * 0.75031128) -
    t22_tmp_tmp_tmp * 2.93549) + t41_tmp_tmp * 0.16200394) - f_I_tmp * 0.1046566)
    - g_I_tmp * 4.0E-6) - h_I_tmp * 2.5327982) - k_I_tmp * 2.5327982) + m_I_tmp *
    0.0421722) - t18_tmp_tmp_tmp * t12_tmp * 5.4E-5) + n_I_tmp * 0.000116) +
    o_I_tmp * 0.000116) + l_I_tmp * 0.1046566) + t29_tmp_tmp * 4.0E-6) - t49_tmp
    * 0.0421722) + e_I_tmp) + t41_tmp_tmp * t12_tmp * 5.4E-5) + I_tmp *
    17.4000966011372) - t34_tmp_tmp * t5_tmp * t7_tmp * 0.0421722) - c_I_tmp *
    t6_tmp * 0.0421722) + g_I_tmp * t12_tmp * 8.0E-6) + t18_tmp_tmp_tmp * t8_tmp
    * t9_tmp * 2.24111494) - h_I_tmp * t9_tmp * 4.0E-6) - k_I_tmp * t9_tmp *
    4.0E-6) - b_I_tmp * 17.4000966011372) - m_I_tmp * t12_tmp * 0.0843444) +
                       n_I_tmp * t9_tmp * 54.66134) + o_I_tmp * t9_tmp *
                      54.66134) - n_I_tmp * t13_tmp * 0.00024) - o_I_tmp *
                    t13_tmp * 0.00024) - t29_tmp_tmp * t12_tmp * 8.0E-6) -
                  t41_tmp_tmp * t8_tmp * t9_tmp * 2.24111494) + t49_tmp *
                 t12_tmp * 0.0843444) - I_tmp * t13_tmp * 17.6523104011372) +
               t2_tmp * t5_tmp * t7_tmp * t8_tmp * t9_tmp * 17.6523104011372) +
              t69_tmp_tmp * t6_tmp * t8_tmp * t9_tmp * 17.6523104011372) +
             b_I_tmp * t27) - f_I_tmp * t5_tmp * t8_tmp * t9_tmp * 0.00024) +
    t19_tmp_tmp * t6_tmp * t7_tmp * t8_tmp * t9_tmp * 0.00024;
  b_I[7] = (((((((((((((((t3_tmp * 539.550468 - t7_tmp * 27.729881) + t44_tmp) +
                        t18) + -t17) + d) + t21) + -t22) + t24) + t71) + t26) +
                t27) + t29) + t69_tmp_tmp * 125.721082) - p_I_tmp * 5.87098) -
            q_I_tmp * 125.721082) + 1680.7855873626529;
  d_I_tmp = (t3_tmp * 269.775234 - t7_tmp * 13.8649405) + t44_tmp;
  b_I[13] = (((((((((((((d_I_tmp + t18) + -t17) + d) + t21) + -t22) + t24) + t71)
                  + t26) + t27) + t29) + t69_tmp_tmp * 62.860541) - p_I_tmp *
              2.93549) - q_I_tmp * 62.860541) + 232.26558389;
  t34_tmp = t8_tmp * t9_tmp;
  e_I_tmp = t4_tmp * 2.5327982 - t8_tmp * 0.000116;
  f_I_tmp = t3_tmp * t8_tmp * t9_tmp * 62.860541;
  b_I[19] = ((((((e_I_tmp + t35_tmp_tmp * 2.93549) + t19_tmp_tmp * 0.0421722) +
                t24_tmp * 4.0E-6) - t34_tmp * 54.66134) + t8_tmp * t13_tmp *
              0.00024) - f_I_tmp) - j_I_tmp * t9_tmp * 17.6523104011372;
  g_I_tmp = t4_tmp * 17.8563124011372 + t9_tmp * 2.24111494;
  h_I_tmp = t7_tmp * t9_tmp * 62.860541;
  b_I[25] = ((((g_I_tmp + t19_tmp_tmp * 54.66134) - j_I_tmp * 4.0E-6) - h_I_tmp)
             + t34_tmp * 0.0421722) + c_I_tmp * 62.860541;
  b_I[31] = 0.0;

  /*  INERTIA_ROW_3 - Computation of the robot specific inertia matrix row for corresponding to joint 3 of 6.  */
  /*  =========================================================================  */
  /*      */
  /*     Irow = inertia_row_3(rob,q)  */
  /*     Irow = rob.inertia_row_3(q)  */
  /*      */
  /*   Description::  */
  /*     Given a full set of joint variables this function computes the  */
  /*     inertia matrix row number 3 of 6 for Quantec Ultra SE 150.  */
  /*      */
  /*   Input::  */
  /*     rob: robot object of Quantec Ultra SE 150 specific class  */
  /*     q:  6-element vector of generalized  */
  /*          coordinates  */
  /*     Angles have to be given in radians!  */
  /*      */
  /*   Output::  */
  /*     Irow:  [1x6] row of the robot inertia matrix  */
  /*      */
  /*   Example::  */
  /*     ---  */
  /*      */
  /*   Known Bugs::  */
  /*     ---  */
  /*      */
  /*   TODO::  */
  /*     ---  */
  /*      */
  /*   References::  */
  /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
  /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
  /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
  /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
  /*      */
  /*   Authors::  */
  /*     This is an autogenerated function!  */
  /*     Code generator written by:  */
  /*     Joern Malzahn  */
  /*     2012 RST, Technische Universitaet Dortmund, Germany  */
  /*     http://www.rst.e-technik.tu-dortmund.de  */
  /*      */
  /*   See also coriolis. */
  /*      */
  /*  Copyright (C) 1993-2021, by Peter I. Corke  */
  /*  Copyright (C) 2012-2021, by Joern Malzahn  */
  /*   */
  /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
  /*   */
  /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
  /*  it under the terms of the GNU Lesser General Public License as published by  */
  /*  the Free Software Foundation, either version 3 of the License, or  */
  /*  (at your option) any later version.  */
  /*    */
  /*  RTB is distributed in the hope that it will be useful,  */
  /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
  /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
  /*  GNU Lesser General Public License for more details.  */
  /*    */
  /*  You should have received a copy of the GNU Leser General Public License  */
  /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
  /*   */
  /*  http://www.petercorke.com  */
  /*   */
  /*  The code generation module emerged during the work on a project funded by  */
  /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
  /*  acknowledge the financial support.  */
  /*  Bugfix */
  /*   In some versions the symbolic toolbox writes the constant $pi$ in */
  /*   capital letters. This way autogenerated functions might not work properly. */
  /*   To fix this issue a local variable is introduced: */
  /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
  /*     02-Mar-2021 15:33:24 */
  t18 = t8_tmp * 0.2093132;
  t21 = t5_tmp * 109.32268;
  t22 = t19_tmp_tmp * t8_tmp * 8.0E-6;
  t24 = t24_tmp * 4.48222988;
  t71 = t4_tmp * t8_tmp * t9_tmp * 0.0843444;
  t17 = d1 * t12_tmp * 0.00024;
  t26 = t12_tmp * 17.4000966011372;
  t27 = t13_tmp * 17.6523104011372;
  t29 = t12_tmp * t13_tmp * -17.6523104011372;
  k_I_tmp = t18_tmp_tmp_tmp * t4_tmp;
  l_I_tmp = t18_tmp_tmp_tmp * t5_tmp;
  m_I_tmp = t34_tmp_tmp * t7_tmp;
  n_I_tmp = t35_tmp_tmp * t6_tmp;
  o_I_tmp = t4_tmp * t6_tmp * t7_tmp;
  p_I_tmp = t18_tmp_tmp_tmp * t9_tmp;
  q_I_tmp = t23_tmp_tmp * t8_tmp;
  t49_tmp = t24_tmp_tmp * t8_tmp;
  I_tmp = t41_tmp_tmp * t9_tmp;
  b_I_tmp = k_I_tmp * t8_tmp;
  c_I_tmp = o_I_tmp * t8_tmp;
  b_I[2] = ((((((((((((((((((((((((((((((((((((t18_tmp_tmp_tmp * -0.16200394 -
    t23_tmp_tmp * 0.75031128) - t24_tmp_tmp * 0.75031128) + t41_tmp_tmp *
    0.16200394) - k_I_tmp * 0.1046566) - l_I_tmp * 4.0E-6) - m_I_tmp * 2.5327982)
    - n_I_tmp * 2.5327982) + p_I_tmp * 0.0421722) - t18_tmp_tmp_tmp * t12_tmp *
    5.4E-5) + q_I_tmp * 0.000116) + t49_tmp * 0.000116) + o_I_tmp * 0.1046566) +
    t29_tmp_tmp * 4.0E-6) - I_tmp * 0.0421722) + t41_tmp_tmp * t12_tmp * 5.4E-5)
    + b_I_tmp * 17.4000966011372) - t34_tmp_tmp * t5_tmp * t7_tmp * 0.0421722) -
    t35_tmp_tmp * t5_tmp * t6_tmp * 0.0421722) + l_I_tmp * t12_tmp * 8.0E-6) +
    t18_tmp_tmp_tmp * t8_tmp * t9_tmp * 2.24111494) - m_I_tmp * t9_tmp * 4.0E-6)
    - n_I_tmp * t9_tmp * 4.0E-6) - c_I_tmp * 17.4000966011372) - p_I_tmp *
                        t12_tmp * 0.0843444) + q_I_tmp * t9_tmp * 54.66134) +
                      t49_tmp * t9_tmp * 54.66134) - q_I_tmp * t13_tmp * 0.00024)
                    - t49_tmp * t13_tmp * 0.00024) - t29_tmp_tmp * t12_tmp *
                   8.0E-6) - t41_tmp_tmp * t8_tmp * t9_tmp * 2.24111494) + I_tmp
                 * t12_tmp * 0.0843444) - b_I_tmp * t13_tmp * 17.6523104011372)
               + t2_tmp * t5_tmp * t7_tmp * t8_tmp * t9_tmp * 17.6523104011372)
              + t69_tmp_tmp * t6_tmp * t8_tmp * t9_tmp * 17.6523104011372) +
             c_I_tmp * t27) - k_I_tmp * t5_tmp * t8_tmp * t9_tmp * 0.00024) +
    t19_tmp_tmp * t6_tmp * t7_tmp * t8_tmp * t9_tmp * 0.00024;
  b_I[8] = (((((((((((((d_I_tmp + t18) + -t17) + d) + t21) + -t22) + t24) + t71)
                 + t26) + t27) + t29) + t69_tmp_tmp * 62.860541) - t7_tmp *
             t8_tmp * 2.93549) - t4_tmp * t7_tmp * t9_tmp * 62.860541) +
    232.26558389;
  b_I[14] = ((((((((((t44_tmp + t18) + -t17) + d) + t21) + -t22) + t24) + t71) +
               t26) + t27) + t29) + 983.59649500111107;
  b_I[20] = ((((e_I_tmp + t19_tmp_tmp * 0.0421722) + t24_tmp * 4.0E-6) - t34_tmp
              * 54.66134) + t8_tmp * t13_tmp * 0.00024) - j_I_tmp * t9_tmp *
    17.6523104011372;
  b_I[26] = ((g_I_tmp + t19_tmp_tmp * 54.66134) - j_I_tmp * 4.0E-6) + t34_tmp *
    0.0421722;
  b_I[32] = 0.0;

  /*  INERTIA_ROW_4 - Computation of the robot specific inertia matrix row for corresponding to joint 4 of 6.  */
  /*  =========================================================================  */
  /*      */
  /*     Irow = inertia_row_4(rob,q)  */
  /*     Irow = rob.inertia_row_4(q)  */
  /*      */
  /*   Description::  */
  /*     Given a full set of joint variables this function computes the  */
  /*     inertia matrix row number 4 of 6 for Quantec Ultra SE 150.  */
  /*      */
  /*   Input::  */
  /*     rob: robot object of Quantec Ultra SE 150 specific class  */
  /*     q:  6-element vector of generalized  */
  /*          coordinates  */
  /*     Angles have to be given in radians!  */
  /*      */
  /*   Output::  */
  /*     Irow:  [1x6] row of the robot inertia matrix  */
  /*      */
  /*   Example::  */
  /*     ---  */
  /*      */
  /*   Known Bugs::  */
  /*     ---  */
  /*      */
  /*   TODO::  */
  /*     ---  */
  /*      */
  /*   References::  */
  /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
  /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
  /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
  /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
  /*      */
  /*   Authors::  */
  /*     This is an autogenerated function!  */
  /*     Code generator written by:  */
  /*     Joern Malzahn  */
  /*     2012 RST, Technische Universitaet Dortmund, Germany  */
  /*     http://www.rst.e-technik.tu-dortmund.de  */
  /*      */
  /*   See also coriolis. */
  /*      */
  /*  Copyright (C) 1993-2021, by Peter I. Corke  */
  /*  Copyright (C) 2012-2021, by Joern Malzahn  */
  /*   */
  /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
  /*   */
  /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
  /*  it under the terms of the GNU Lesser General Public License as published by  */
  /*  the Free Software Foundation, either version 3 of the License, or  */
  /*  (at your option) any later version.  */
  /*    */
  /*  RTB is distributed in the hope that it will be useful,  */
  /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
  /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
  /*  GNU Lesser General Public License for more details.  */
  /*    */
  /*  You should have received a copy of the GNU Leser General Public License  */
  /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
  /*   */
  /*  http://www.petercorke.com  */
  /*   */
  /*  The code generation module emerged during the work on a project funded by  */
  /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
  /*  acknowledge the financial support.  */
  /*  Bugfix */
  /*   In some versions the symbolic toolbox writes the constant $pi$ in */
  /*   capital letters. This way autogenerated functions might not work properly. */
  /*   To fix this issue a local variable is introduced: */
  /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
  /*     02-Mar-2021 15:33:25 */
  d_I_tmp = t18_tmp_tmp_tmp * t4_tmp;
  e_I_tmp = t18_tmp_tmp_tmp * t8_tmp;
  g_I_tmp = t4_tmp * t6_tmp * t7_tmp;
  k_I_tmp = t6_tmp * t7_tmp * t8_tmp;
  b_I[3] = ((((((((((((((((((((((((((t8_tmp * 0.89341 - t23_tmp_tmp *
    18.3299492011372) - t24_tmp_tmp * 18.3299492011372) + i_I_tmp) + t24_tmp *
    19.131469) + d_I_tmp * 0.000116) + e_I_tmp * 2.5327982) + t34_tmp_tmp *
    t9_tmp * 62.860541) - t23_tmp_tmp * t8_tmp * 0.1046566) - t24_tmp_tmp *
    t8_tmp * 0.1046566) - g_I_tmp * 0.000116) + t23_tmp_tmp * t13_tmp *
    17.6523104011372) + t24_tmp_tmp * t13_tmp * 17.6523104011372) - k_I_tmp *
    2.5327982) + d_I_tmp * t9_tmp * 54.66134) + t18_tmp_tmp_tmp * t5_tmp *
                       t8_tmp * 0.0421722) - d_I_tmp * t13_tmp * 0.00024) +
                     e_I_tmp * t9_tmp * 4.0E-6) - t34_tmp_tmp * t7_tmp * t9_tmp *
                    2.24111494) - t35_tmp_tmp * t6_tmp * t9_tmp * 2.24111494) +
                  t2_tmp * t5_tmp * t7_tmp * t9_tmp * 0.00024) + t3_tmp * t5_tmp
                 * t6_tmp * t9_tmp * 0.00024) - g_I_tmp * t9_tmp * 54.66134) -
               t5_tmp * t6_tmp * t7_tmp * t8_tmp * 0.0421722) + g_I_tmp *
              t13_tmp * 0.00024) - k_I_tmp * t9_tmp * 4.0E-6) + d_I_tmp * t5_tmp
            * t9_tmp * 17.6523104011372) - t19_tmp_tmp * t6_tmp * t7_tmp *
    t9_tmp * 17.6523104011372;
  d_I_tmp = (((((t8_tmp * t13_tmp * 0.00024 + t24_tmp * 4.0E-6) + -(t8_tmp *
    t9_tmp * 54.66134)) + t19_tmp_tmp * 0.0421722) + t4_tmp * 2.5327982) +
             -(t8_tmp * 0.000116)) + -(t5_tmp * t8_tmp * t9_tmp *
    17.6523104011372);
  b_I[9] = (d_I_tmp + t35_tmp_tmp * 2.93549) - f_I_tmp;
  b_I[15] = d_I_tmp;
  b_I[21] = (t13_tmp * -17.6523104011372 - t44_tmp) + 102.82487920113719;
  d_I_tmp = t5_tmp * 0.0421722 + t9_tmp * 4.0E-6;
  b_I[27] = d_I_tmp;
  b_I[33] = 0.0;

  /*  INERTIA_ROW_5 - Computation of the robot specific inertia matrix row for corresponding to joint 5 of 6.  */
  /*  =========================================================================  */
  /*      */
  /*     Irow = inertia_row_5(rob,q)  */
  /*     Irow = rob.inertia_row_5(q)  */
  /*      */
  /*   Description::  */
  /*     Given a full set of joint variables this function computes the  */
  /*     inertia matrix row number 5 of 6 for Quantec Ultra SE 150.  */
  /*      */
  /*   Input::  */
  /*     rob: robot object of Quantec Ultra SE 150 specific class  */
  /*     q:  6-element vector of generalized  */
  /*          coordinates  */
  /*     Angles have to be given in radians!  */
  /*      */
  /*   Output::  */
  /*     Irow:  [1x6] row of the robot inertia matrix  */
  /*      */
  /*   Example::  */
  /*     ---  */
  /*      */
  /*   Known Bugs::  */
  /*     ---  */
  /*      */
  /*   TODO::  */
  /*     ---  */
  /*      */
  /*   References::  */
  /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
  /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
  /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
  /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
  /*      */
  /*   Authors::  */
  /*     This is an autogenerated function!  */
  /*     Code generator written by:  */
  /*     Joern Malzahn  */
  /*     2012 RST, Technische Universitaet Dortmund, Germany  */
  /*     http://www.rst.e-technik.tu-dortmund.de  */
  /*      */
  /*   See also coriolis. */
  /*      */
  /*  Copyright (C) 1993-2021, by Peter I. Corke  */
  /*  Copyright (C) 2012-2021, by Joern Malzahn  */
  /*   */
  /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
  /*   */
  /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
  /*  it under the terms of the GNU Lesser General Public License as published by  */
  /*  the Free Software Foundation, either version 3 of the License, or  */
  /*  (at your option) any later version.  */
  /*    */
  /*  RTB is distributed in the hope that it will be useful,  */
  /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
  /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
  /*  GNU Lesser General Public License for more details.  */
  /*    */
  /*  You should have received a copy of the GNU Leser General Public License  */
  /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
  /*   */
  /*  http://www.petercorke.com  */
  /*   */
  /*  The code generation module emerged during the work on a project funded by  */
  /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
  /*  acknowledge the financial support.  */
  /*  Bugfix */
  /*   In some versions the symbolic toolbox writes the constant $pi$ in */
  /*   capital letters. This way autogenerated functions might not work properly. */
  /*   To fix this issue a local variable is introduced: */
  /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
  /*     02-Mar-2021 15:33:26 */
  e_I_tmp = t18_tmp_tmp_tmp * t4_tmp;
  f_I_tmp = t68_tmp_tmp * t7_tmp;
  g_I_tmp = t3_tmp * t5_tmp * t6_tmp;
  b_I[4] = ((((((((((((((j_I_tmp * 19.131469 + t18_tmp_tmp_tmp * t8_tmp *
    17.8563124011372) - f_I_tmp * 0.0421722) - g_I_tmp * 0.0421722) +
                      t68_tmp_tmp * t8_tmp * 62.860541) - t2_tmp * t7_tmp *
                     t9_tmp * 4.0E-6) - t3_tmp * t6_tmp * t9_tmp * 4.0E-6) -
                   t6_tmp * t7_tmp * t8_tmp * 17.8563124011372) + e_I_tmp *
                  t5_tmp * 4.0E-6) - e_I_tmp * t9_tmp * 0.0421722) +
                t18_tmp_tmp_tmp * t5_tmp * t8_tmp * 54.66134) - f_I_tmp * t8_tmp
               * 2.24111494) - g_I_tmp * t8_tmp * 2.24111494) - t19_tmp_tmp *
             t6_tmp * t7_tmp * 4.0E-6) + t4_tmp * t6_tmp * t7_tmp * t9_tmp *
            0.0421722) - t5_tmp * t6_tmp * t7_tmp * t8_tmp * 54.66134;
  e_I_tmp = (((-(j_I_tmp * 4.0E-6) + t19_tmp_tmp * 54.66134) + t8_tmp * t9_tmp *
              0.0421722) + t9_tmp * 2.24111494) + t4_tmp * 17.8563124011372;
  b_I[10] = (e_I_tmp - h_I_tmp) + t3_tmp * t4_tmp * t5_tmp * 62.860541;
  b_I[16] = e_I_tmp;
  b_I[22] = d_I_tmp;
  b_I[28] = 117.188220609754;
  b_I[34] = 0.0;
  for (i = 0; i < 6; i++) {
    b_I[6 * i + 5] = dv[i];
  }
}

/* End of code generation (inertia_150.c) */
