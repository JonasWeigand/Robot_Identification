/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * inertia_125.c
 *
 * Code generation for function 'inertia_125'
 *
 */

/* Include files */
#include "inertia_125.h"
#include "mwmathutil.h"
#include "rt_nonfinite.h"
#include "runge_kutta_4.h"
#include "runge_kutta_4_data.h"
#include <string.h>

/* Function Definitions */
void inertia_125(const real_T q[6], real_T b_I[36])
{
  real_T t2_tmp;
  real_T t3_tmp;
  real_T t4_tmp;
  real_T t5_tmp;
  real_T t6_tmp;
  real_T t7_tmp;
  real_T t8_tmp;
  real_T t9_tmp;
  real_T t10;
  real_T t11;
  real_T t12_tmp;
  real_T t13_tmp;
  real_T t18_tmp_tmp_tmp;
  real_T t18_tmp;
  real_T b_t18_tmp;
  real_T t18;
  real_T t19_tmp_tmp;
  real_T t19_tmp;
  real_T t19;
  real_T t21;
  real_T t22_tmp_tmp_tmp;
  real_T t22_tmp;
  real_T t22;
  real_T t23_tmp_tmp;
  real_T t23;
  real_T t24_tmp_tmp;
  real_T t24;
  real_T t28_tmp;
  real_T t28;
  real_T t29_tmp_tmp;
  real_T t29;
  real_T t34_tmp_tmp;
  real_T t34_tmp;
  real_T b_t34_tmp;
  real_T t34;
  real_T t35_tmp_tmp;
  real_T t71;
  real_T t35_tmp;
  real_T t35;
  real_T t41_tmp_tmp;
  real_T t17;
  real_T t41;
  real_T t42_tmp;
  real_T t42;
  real_T t44_tmp;
  real_T t44;
  real_T t45_tmp;
  real_T t45;
  real_T t46;
  real_T t47;
  real_T t27;
  real_T t48;
  real_T t49_tmp;
  real_T t49;
  real_T t50;
  real_T t51;
  real_T t56;
  real_T t59;
  real_T t62_tmp;
  real_T b_t62_tmp;
  real_T t62;
  real_T t63_tmp;
  real_T b_t63_tmp;
  real_T t63;
  real_T t65;
  real_T t26;
  real_T t66;
  real_T t68_tmp_tmp;
  real_T t68_tmp;
  real_T b_t68_tmp;
  real_T t68;
  real_T t69_tmp_tmp;
  real_T t69_tmp;
  real_T b_t69_tmp;
  real_T t69;
  real_T t14;
  real_T t15;
  real_T t30;
  real_T t31;
  real_T t38;
  real_T t39;
  real_T t57;
  real_T t58;
  real_T t70;
  real_T d;
  real_T I_tmp;
  real_T b_I_tmp;
  real_T c_I_tmp;
  real_T t25_tmp;
  real_T d1;
  real_T d2;
  real_T d3;
  real_T d4;
  real_T d5;
  real_T d6;
  real_T d7;
  real_T d8;
  real_T d9;
  real_T d10;
  real_T d11;
  real_T d12;
  real_T d13;
  real_T d14;
  real_T d15;
  real_T d16;
  real_T d17;
  real_T d18;
  real_T d19;
  real_T d20;
  real_T d21;
  real_T d22;
  real_T d23;
  real_T d_I_tmp;
  real_T e_I_tmp;
  real_T f_I_tmp;
  real_T g_I_tmp;
  real_T h_I_tmp;
  real_T i_I_tmp;
  real_T j_I_tmp;
  real_T k_I_tmp;
  real_T l_I_tmp;
  real_T m_I_tmp;
  real_T n_I_tmp;
  real_T o_I_tmp;
  real_T p_I_tmp;
  real_T q_I_tmp;
  int32_T i;

  /*  INERTIA - Inertia matrix for the Quantec Ultra SE 125 arm.  */
  /*  =========================================================================  */
  /*      */
  /*     I = inertia(rob,q)  */
  /*     I = rob.inertia(q)  */
  /*      */
  /*   Description::  */
  /*     Given a full set of joint variables the function computes the  */
  /*     inertia Matrix of the robot.  */
  /*      */
  /*   Input::  */
  /*     rob: robot object of Quantec Ultra SE 125 specific class  */
  /*     q:  6-element vector of generalized  */
  /*          coordinates  */
  /*     Angles have to be given in radians!  */
  /*      */
  /*   Output::  */
  /*     I:  [6x6] inertia matrix  */
  /*      */
  /*   Example::  */
  /*     ---  */
  /*      */
  /*   Known Bugs::  */
  /*     ---  */
  /*      */
  /*   TODO::  */
  /*     ---  */
  /*      */
  /*   References::  */
  /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
  /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
  /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
  /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
  /*      */
  /*   Authors::  */
  /*     This is an autogenerated function!  */
  /*     Code generator written by:  */
  /*     Joern Malzahn  */
  /*     2012 RST, Technische Universitaet Dortmund, Germany  */
  /*     http://www.rst.e-technik.tu-dortmund.de  */
  /*      */
  /*   See also coriolis. */
  /*      */
  /*  Copyright (C) 1993-2021, by Peter I. Corke  */
  /*  Copyright (C) 2012-2021, by Joern Malzahn  */
  /*   */
  /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
  /*   */
  /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
  /*  it under the terms of the GNU Lesser General Public License as published by  */
  /*  the Free Software Foundation, either version 3 of the License, or  */
  /*  (at your option) any later version.  */
  /*    */
  /*  RTB is distributed in the hope that it will be useful,  */
  /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
  /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
  /*  GNU Lesser General Public License for more details.  */
  /*    */
  /*  You should have received a copy of the GNU Leser General Public License  */
  /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
  /*   */
  /*  http://www.petercorke.com  */
  /*   */
  /*  The code generation module emerged during the work on a project funded by  */
  /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
  /*  acknowledge the financial support.  */
  memset(&b_I[0], 0, 36U * sizeof(real_T));

  /*  INERTIA_ROW_1 - Computation of the robot specific inertia matrix row for corresponding to joint 1 of 6.  */
  /*  =========================================================================  */
  /*      */
  /*     Irow = inertia_row_1(rob,q)  */
  /*     Irow = rob.inertia_row_1(q)  */
  /*      */
  /*   Description::  */
  /*     Given a full set of joint variables this function computes the  */
  /*     inertia matrix row number 1 of 6 for Quantec Ultra SE 125.  */
  /*      */
  /*   Input::  */
  /*     rob: robot object of Quantec Ultra SE 125 specific class  */
  /*     q:  6-element vector of generalized  */
  /*          coordinates  */
  /*     Angles have to be given in radians!  */
  /*      */
  /*   Output::  */
  /*     Irow:  [1x6] row of the robot inertia matrix  */
  /*      */
  /*   Example::  */
  /*     ---  */
  /*      */
  /*   Known Bugs::  */
  /*     ---  */
  /*      */
  /*   TODO::  */
  /*     ---  */
  /*      */
  /*   References::  */
  /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
  /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
  /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
  /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
  /*      */
  /*   Authors::  */
  /*     This is an autogenerated function!  */
  /*     Code generator written by:  */
  /*     Joern Malzahn  */
  /*     2012 RST, Technische Universitaet Dortmund, Germany  */
  /*     http://www.rst.e-technik.tu-dortmund.de  */
  /*      */
  /*   See also coriolis. */
  /*      */
  /*  Copyright (C) 1993-2021, by Peter I. Corke  */
  /*  Copyright (C) 2012-2021, by Joern Malzahn  */
  /*   */
  /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
  /*   */
  /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
  /*  it under the terms of the GNU Lesser General Public License as published by  */
  /*  the Free Software Foundation, either version 3 of the License, or  */
  /*  (at your option) any later version.  */
  /*    */
  /*  RTB is distributed in the hope that it will be useful,  */
  /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
  /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
  /*  GNU Lesser General Public License for more details.  */
  /*    */
  /*  You should have received a copy of the GNU Leser General Public License  */
  /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
  /*   */
  /*  http://www.petercorke.com  */
  /*   */
  /*  The code generation module emerged during the work on a project funded by  */
  /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
  /*  acknowledge the financial support.  */
  /*  Bugfix */
  /*   In some versions the symbolic toolbox writes the constant $pi$ in */
  /*   capital letters. This way autogenerated functions might not work properly. */
  /*   To fix this issue a local variable is introduced: */
  /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
  /*     02-Mar-2021 15:14:59 */
  t2_tmp = muDoubleScalarCos(q[1]);
  t3_tmp = muDoubleScalarCos(q[2]);
  t4_tmp = muDoubleScalarCos(q[3]);
  t5_tmp = muDoubleScalarCos(q[4]);
  t6_tmp = muDoubleScalarSin(q[1]);
  t7_tmp = muDoubleScalarSin(q[2]);
  t8_tmp = muDoubleScalarSin(q[3]);
  t9_tmp = muDoubleScalarSin(q[4]);
  t10 = t2_tmp * t2_tmp;
  t11 = t3_tmp * t3_tmp;
  t12_tmp = t4_tmp * t4_tmp;
  t13_tmp = t5_tmp * t5_tmp;
  t18_tmp_tmp_tmp = t2_tmp * t3_tmp;
  t18_tmp = t18_tmp_tmp_tmp * t4_tmp;
  b_t18_tmp = t18_tmp * t5_tmp;
  t18 = b_t18_tmp * t8_tmp * t9_tmp * 0.00024;
  t19_tmp_tmp = t4_tmp * t5_tmp;
  t19_tmp = t19_tmp_tmp * t6_tmp * t7_tmp;
  t19 = t19_tmp * t8_tmp * t9_tmp * 0.00024;
  t21 = t18_tmp * 0.1046566;
  t22_tmp_tmp_tmp = t4_tmp * t6_tmp;
  t22_tmp = t22_tmp_tmp_tmp * t7_tmp;
  t22 = t22_tmp * 0.1046566;
  t23_tmp_tmp = t2_tmp * t7_tmp;
  t23 = t23_tmp_tmp * 0.75031128;
  t24_tmp_tmp = t3_tmp * t6_tmp;
  t24 = t24_tmp_tmp * 0.75031128;
  t28_tmp = t18_tmp_tmp_tmp * t5_tmp;
  t28 = t28_tmp * 4.0E-6;
  t29_tmp_tmp = t5_tmp * t6_tmp * t7_tmp;
  t29 = t29_tmp_tmp * 4.0E-6;
  t34_tmp_tmp = t2_tmp * t4_tmp;
  t34_tmp = t34_tmp_tmp * t7_tmp;
  b_t34_tmp = t34_tmp * t9_tmp;
  t34 = b_t34_tmp * 4.0E-6;
  t35_tmp_tmp = t3_tmp * t4_tmp;
  t71 = t35_tmp_tmp * t6_tmp;
  t35_tmp = t71 * t9_tmp;
  t35 = t35_tmp * 4.0E-6;
  t41_tmp_tmp = t6_tmp * t7_tmp;
  t17 = t41_tmp_tmp * t9_tmp;
  t41 = t17 * 0.0421722;
  t42_tmp = t18_tmp_tmp_tmp * t9_tmp;
  t42 = t42_tmp * 0.0421722;
  t44_tmp = t23_tmp_tmp * t8_tmp;
  t44 = t44_tmp * 0.000116;
  t45_tmp = t24_tmp_tmp * t8_tmp;
  t45 = t45_tmp * 0.000116;
  t46 = t44_tmp * t9_tmp * 46.16134;
  t47 = t45_tmp * t9_tmp * 46.16134;
  t27 = t34_tmp_tmp * t5_tmp;
  t48 = t27 * t7_tmp * 0.0421722;
  t49_tmp = t35_tmp_tmp * t5_tmp;
  t49 = t49_tmp * t6_tmp * 0.0421722;
  t50 = t34_tmp * 2.5327982;
  t51 = t71 * 2.5327982;
  t56 = t41_tmp_tmp * 0.16200394;
  t59 = t18_tmp_tmp_tmp * 0.16200394;
  t62_tmp = t18_tmp_tmp_tmp * t8_tmp;
  b_t62_tmp = t62_tmp * t9_tmp;
  t62 = b_t62_tmp * 1.89261494;
  t63_tmp = t41_tmp_tmp * t8_tmp;
  b_t63_tmp = t63_tmp * t9_tmp;
  t63 = b_t63_tmp * 1.89261494;
  t71 = t18_tmp * t8_tmp;
  t65 = t71 * 14.51751958424709;
  t26 = t22_tmp * t8_tmp;
  t66 = t26 * 14.51751958424709;
  t68_tmp_tmp = t2_tmp * t5_tmp;
  t68_tmp = t68_tmp_tmp * t7_tmp;
  b_t68_tmp = t68_tmp * t8_tmp;
  t68 = b_t68_tmp * t9_tmp * 14.76973338424709;
  t69_tmp_tmp = t3_tmp * t5_tmp;
  t69_tmp = t69_tmp_tmp * t6_tmp;
  b_t69_tmp = t69_tmp * t8_tmp;
  t69 = b_t69_tmp * t9_tmp * 14.76973338424709;
  t14 = t44_tmp * t13_tmp * 0.00024;
  t15 = t45_tmp * t13_tmp * 0.00024;
  t30 = t18_tmp_tmp_tmp * t12_tmp * 5.4E-5;
  t31 = t41_tmp_tmp * t12_tmp * 5.4E-5;
  t38 = t28_tmp * t12_tmp * 8.0E-6;
  t39 = t29_tmp_tmp * t12_tmp * 8.0E-6;
  t57 = t42_tmp * t12_tmp * 0.0843444;
  t58 = t17 * t12_tmp * 0.0843444;
  t70 = t71 * t13_tmp * 14.76973338424709;
  t71 = t26 * t13_tmp * 14.76973338424709;
  t17 = t5_tmp * t10;
  d = muDoubleScalarSin(q[3] * 2.0) * 2.7E-5;
  t26 = t8_tmp * t10;
  I_tmp = t2_tmp * t6_tmp;
  b_I_tmp = t3_tmp * t7_tmp;
  c_I_tmp = t4_tmp * t8_tmp;
  t25_tmp = t4_tmp * t9_tmp;
  d1 = t5_tmp * t9_tmp;
  t34_tmp = t10 * t11;
  t42_tmp = t10 * t12_tmp;
  d2 = t11 * t12_tmp;
  d3 = t18_tmp_tmp_tmp * t6_tmp;
  d4 = t68_tmp_tmp * t6_tmp;
  d5 = t34_tmp_tmp * t6_tmp;
  d6 = t35_tmp_tmp * t7_tmp;
  d7 = t69_tmp_tmp * t7_tmp;
  d8 = I_tmp * t8_tmp;
  d9 = b_I_tmp * t8_tmp;
  d10 = t19_tmp_tmp * t8_tmp;
  d11 = c_I_tmp * t9_tmp;
  d12 = c_I_tmp * t10;
  d13 = t25_tmp * t10;
  d14 = d1 * t10;
  d15 = d1 * t11;
  d16 = t34_tmp * t12_tmp;
  d17 = d3 * t7_tmp;
  d18 = d5 * t9_tmp;
  d19 = d4 * t8_tmp;
  d20 = d6 * t9_tmp;
  d21 = d5 * t11;
  d22 = d7 * t8_tmp;
  d23 = d6 * t10;
  d_I_tmp = d9 * t9_tmp;
  e_I_tmp = d10 * t10;
  f_I_tmp = d11 * t10;
  g_I_tmp = d14 * t11;
  h_I_tmp = t18_tmp * t6_tmp;
  i_I_tmp = h_I_tmp * t7_tmp;
  j_I_tmp = t28_tmp * t6_tmp * t7_tmp;
  k_I_tmp = t27 * t6_tmp * t9_tmp;
  l_I_tmp = t49_tmp * t7_tmp * t9_tmp;
  m_I_tmp = d17 * t12_tmp;
  n_I_tmp = i_I_tmp * t8_tmp;
  o_I_tmp = j_I_tmp * t9_tmp;
  p_I_tmp = t7_tmp * t8_tmp;
  q_I_tmp = t4_tmp * t7_tmp * t9_tmp;
  b_I[0] =
    (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
    (((((((((((((((((((((((((((((((((((t2_tmp * 358.462594 + t5_tmp * 92.32268)
    + t6_tmp * 0.237384) + t10 * 360.11833097) - t11 * 204.13072363) - t12_tmp *
    14.51751958424709) + muDoubleScalarSin(q[1] * 2.0) * 8.9267942) +
    muDoubleScalarSin(q[2] * 2.0) * 8.34719628) - d) + t18_tmp_tmp_tmp *
    146.711012) - t23_tmp_tmp * 7.722029) - t24_tmp_tmp * 7.722029) + t3_tmp *
    t10 * 482.050468) - t41_tmp_tmp * 146.711012) - t17 * 92.32268) - t5_tmp *
    t11 * 92.32268) - t7_tmp * t10 * 25.372381) + t26 * 0.2093132) + t8_tmp *
    t11 * 0.2093132) + t34_tmp * 408.26144726) + t42_tmp * 14.51751958424709) -
    t10 * t13_tmp * 14.76973338424709) + d2 * 14.51751958424709) - t11 * t13_tmp
    * 14.76973338424709) + t12_tmp * t13_tmp * 14.76973338424709) + t28_tmp *
    32.312938) - d3 * 25.372381) + d5 * 0.000232) + d4 * 3.78522988) + d6 *
    0.000232) - I_tmp * t7_tmp * 482.050468) + d7 * 3.78522988) + d8 * 5.0655964)
    - t44_tmp * 1.78682) - t45_tmp * 1.78682) + d10 * 8.0E-6) + t69_tmp_tmp *
    t10 * 106.171082) + d9 * 5.0655964) - t29_tmp_tmp * 32.312938) - I_tmp * t11
    * 33.38878512) - b_I_tmp * t10 * 33.38878512) - d11 * 0.0843444) + d12 *
    5.4E-5) + c_I_tmp * t11 * 5.4E-5) + d13 * 3.78522988) + t25_tmp * t11 *
    3.78522988) - d14 * 0.00024) - d15 * 0.00024) - p_I_tmp * t10 * 5.87098) +
    d1 * t12_tmp * 0.00024) + t17 * t11 * 184.64536) - t26 * t11 * 0.4186264) -
    d16 * 29.03503916849419) + t34_tmp * t13_tmp * 29.53946676849419) - t42_tmp *
    t13_tmp * 14.76973338424709) - d2 * t13_tmp * 14.76973338424709) - d17 *
    408.26144726) - d3 * t8_tmp * 5.87098) - d4 * t7_tmp * 106.171082) + d18 *
    92.32268) + d19 * 0.0843444) - b_t34_tmp * 32.312938) - t35_tmp * 32.312938)
    - d21 * 0.000464) + d20 * 92.32268) + d22 * 0.0843444) - d4 * t11 *
    7.57045976) - d23 * 0.000464) - d5 * t13_tmp * 0.00048) + d8 * t9_tmp *
    8.0E-6) - d7 * t10 * 7.57045976) - d8 * t11 * 10.1311928) - t3_tmp * t4_tmp *
    t7_tmp * t13_tmp * 0.00048) + d_I_tmp * 8.0E-6) - e_I_tmp * 8.0E-6) - d9 *
    t10 * 10.1311928) - d10 * t11 * 8.0E-6) - q_I_tmp * t10 * 106.171082) +
    f_I_tmp * 0.0843444) + d11 * t11 * 0.0843444) - d12 * t11 * 0.000108) - d13 *
    t11 * 7.57045976) + g_I_tmp * 0.00048) - d14 * t12_tmp * 0.00024) - d15 *
    t12_tmp * 0.00024) + d16 * t13_tmp * 29.53946676849419) - j_I_tmp *
    184.64536) - h_I_tmp * t9_tmp * 106.171082) + d17 * t8_tmp * 0.4186264) +
    k_I_tmp * 29.53946676849419) + l_I_tmp * 29.53946676849419) + m_I_tmp *
    29.03503916849419) - d17 * t13_tmp * 29.53946676849419) - d18 * t11 *
    184.64536) - d19 * t11 * 0.1686888) - d20 * t10 * 184.64536) - d22 * t10 *
                     0.1686888) + d21 * t13_tmp * 0.00096) - t2_tmp * t6_tmp *
                   t8_tmp * t9_tmp * t11 * 1.6E-5) + d23 * t13_tmp * 0.00096) -
                 d_I_tmp * t10 * 1.6E-5) + e_I_tmp * t11 * 1.6E-5) - f_I_tmp *
               t11 * 0.1686888) + g_I_tmp * t12_tmp * 0.00048) + n_I_tmp *
             0.000108) + i_I_tmp * t9_tmp * 7.57045976) - o_I_tmp * 0.00048) -
          k_I_tmp * t11 * 59.07893353698838) - l_I_tmp * t10 * 59.07893353698838)
        - m_I_tmp * t13_tmp * 29.53946676849419) - b_t18_tmp * t6_tmp * t7_tmp *
       t8_tmp * 1.6E-5) + n_I_tmp * t9_tmp * 0.1686888) - o_I_tmp * t12_tmp *
     0.00048) + 957.74108667730832;
  d_I_tmp = t2_tmp * 0.11686308 + t6_tmp * 18.25116472;
  e_I_tmp = t6_tmp * t8_tmp * t9_tmp * 53.085541;
  b_I[6] = (((((((((((((((((((((((((((((((((((((((d_I_tmp + -t14) + -t15) + t19)
    + -t18) + t22) + -t21) + -t23) + -t24) + t29) + t31) + -t28) + -t30) + -t34)
    + -t35) + t38) + -t39) + t42) + -t41) + t44) + t45) + t46) + t47) + -t48) +
    -t49) + -t50) + -t51) + t56) + t58) + -t57) + -t59) + t62) + -t63) + t65) +
                 -t66) + t68) + t69) + t71) + -t70) - t22_tmp_tmp_tmp * 2.93549)
    + e_I_tmp;
  b_I[12] = ((((((((((((((((((((((((((((((((((((-t14 + -t15) + t19) + -t18) +
    t22) + -t21) + -t23) + -t24) + t29) + t31) + -t28) + -t30) + -t34) + -t35) +
    t38) + -t39) + t42) + -t41) + t44) + t45) + t46) + t47) + -t48) + -t49) +
    -t50) + -t51) + t56) + t58) + -t57) + -t59) + t62) + -t63) + t65) + -t66) +
               t68) + t69) + t71) + -t70;
  f_I_tmp = t18_tmp * t9_tmp;
  g_I_tmp = t28_tmp * t8_tmp;
  h_I_tmp = t29_tmp_tmp * t8_tmp;
  i_I_tmp = t2_tmp * t8_tmp * 2.93549;
  b_I[18] = ((((((((((((((((((((((((((t8_tmp * 0.89341 - t23_tmp_tmp *
    15.44737218424709) - t24_tmp_tmp * 15.44737218424709) + i_I_tmp) + t25_tmp *
    16.156469) + t18_tmp * 0.000116) + t62_tmp * 2.5327982) + t34_tmp_tmp *
    t9_tmp * 53.085541) - t44_tmp * 0.1046566) - t45_tmp * 0.1046566) - t22_tmp *
    0.000116) - t63_tmp * 2.5327982) + t23_tmp_tmp * t13_tmp * 14.76973338424709)
    + t24_tmp_tmp * t13_tmp * 14.76973338424709) + f_I_tmp * 46.16134) + g_I_tmp
                        * 0.0421722) - t18_tmp * t13_tmp * 0.00024) + b_t62_tmp *
                      4.0E-6) - b_t34_tmp * 1.89261494) - t35_tmp * 1.89261494)
                   + t68_tmp * t9_tmp * 0.00024) + t69_tmp * t9_tmp * 0.00024) -
                 t22_tmp * t9_tmp * 46.16134) - h_I_tmp * 0.0421722) + t22_tmp *
               t13_tmp * 0.00024) - b_t63_tmp * 4.0E-6) + b_t18_tmp * t9_tmp *
             14.76973338424709) - t19_tmp * t9_tmp * 14.76973338424709;
  j_I_tmp = t5_tmp * t8_tmp;
  b_I[24] = ((((((((((((((j_I_tmp * 16.156469 + t4_tmp * t28) + t4_tmp * t41) +
                        t62_tmp * 14.973735384247091) - t68_tmp * 0.0421722) -
                      t69_tmp * 0.0421722) + t68_tmp_tmp * t8_tmp * 53.085541) -
                    t23_tmp_tmp * t9_tmp * 4.0E-6) - t24_tmp_tmp * t9_tmp *
                   4.0E-6) - t63_tmp * 14.973735384247091) - f_I_tmp * 0.0421722)
                + g_I_tmp * 46.16134) - b_t68_tmp * 1.89261494) - b_t69_tmp *
              1.89261494) - t19_tmp * 4.0E-6) - h_I_tmp * 46.16134;
  b_I[30] = 0.0;

  /*  INERTIA_ROW_2 - Computation of the robot specific inertia matrix row for corresponding to joint 2 of 6.  */
  /*  =========================================================================  */
  /*      */
  /*     Irow = inertia_row_2(rob,q)  */
  /*     Irow = rob.inertia_row_2(q)  */
  /*      */
  /*   Description::  */
  /*     Given a full set of joint variables this function computes the  */
  /*     inertia matrix row number 2 of 6 for Quantec Ultra SE 125.  */
  /*      */
  /*   Input::  */
  /*     rob: robot object of Quantec Ultra SE 125 specific class  */
  /*     q:  6-element vector of generalized  */
  /*          coordinates  */
  /*     Angles have to be given in radians!  */
  /*      */
  /*   Output::  */
  /*     Irow:  [1x6] row of the robot inertia matrix  */
  /*      */
  /*   Example::  */
  /*     ---  */
  /*      */
  /*   Known Bugs::  */
  /*     ---  */
  /*      */
  /*   TODO::  */
  /*     ---  */
  /*      */
  /*   References::  */
  /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
  /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
  /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
  /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
  /*      */
  /*   Authors::  */
  /*     This is an autogenerated function!  */
  /*     Code generator written by:  */
  /*     Joern Malzahn  */
  /*     2012 RST, Technische Universitaet Dortmund, Germany  */
  /*     http://www.rst.e-technik.tu-dortmund.de  */
  /*      */
  /*   See also coriolis. */
  /*      */
  /*  Copyright (C) 1993-2021, by Peter I. Corke  */
  /*  Copyright (C) 2012-2021, by Joern Malzahn  */
  /*   */
  /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
  /*   */
  /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
  /*  it under the terms of the GNU Lesser General Public License as published by  */
  /*  the Free Software Foundation, either version 3 of the License, or  */
  /*  (at your option) any later version.  */
  /*    */
  /*  RTB is distributed in the hope that it will be useful,  */
  /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
  /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
  /*  GNU Lesser General Public License for more details.  */
  /*    */
  /*  You should have received a copy of the GNU Leser General Public License  */
  /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
  /*   */
  /*  http://www.petercorke.com  */
  /*   */
  /*  The code generation module emerged during the work on a project funded by  */
  /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
  /*  acknowledge the financial support.  */
  /*  Bugfix */
  /*   In some versions the symbolic toolbox writes the constant $pi$ in */
  /*   capital letters. This way autogenerated functions might not work properly. */
  /*   To fix this issue a local variable is introduced: */
  /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
  /*     02-Mar-2021 15:15:01 */
  t18 = t8_tmp * 0.2093132;
  t21 = t19_tmp_tmp * t8_tmp * 8.0E-6;
  t23 = t5_tmp * 92.32268;
  t24 = t4_tmp * t8_tmp * t9_tmp * 0.0843444;
  t71 = t25_tmp * 3.78522988;
  t42_tmp = muDoubleScalarSin(q[4] * 2.0) * 0.00012;
  t17 = d1 * t12_tmp * 0.00024;
  t26 = t12_tmp * 14.51751958424709;
  t27 = t13_tmp * 14.76973338424709;
  t29 = t12_tmp * t13_tmp * -14.76973338424709;
  f_I_tmp = t18_tmp_tmp_tmp * t4_tmp;
  g_I_tmp = t18_tmp_tmp_tmp * t5_tmp;
  h_I_tmp = t34_tmp_tmp * t7_tmp;
  k_I_tmp = t35_tmp_tmp * t6_tmp;
  l_I_tmp = t22_tmp_tmp_tmp * t7_tmp;
  m_I_tmp = t18_tmp_tmp_tmp * t9_tmp;
  n_I_tmp = t23_tmp_tmp * t8_tmp;
  o_I_tmp = t24_tmp_tmp * t8_tmp;
  t49_tmp = t41_tmp_tmp * t9_tmp;
  I_tmp = f_I_tmp * t8_tmp;
  b_I_tmp = l_I_tmp * t8_tmp;
  c_I_tmp = t35_tmp_tmp * t5_tmp;
  b_I[1] = (((((((((((((((((((((((((((((((((((((((d_I_tmp - t18_tmp_tmp_tmp *
    0.16200394) - t23_tmp_tmp * 0.75031128) - t24_tmp_tmp * 0.75031128) -
    t22_tmp_tmp_tmp * 2.93549) + t41_tmp_tmp * 0.16200394) - f_I_tmp * 0.1046566)
    - g_I_tmp * 4.0E-6) - h_I_tmp * 2.5327982) - k_I_tmp * 2.5327982) + m_I_tmp *
    0.0421722) - t18_tmp_tmp_tmp * t12_tmp * 5.4E-5) + n_I_tmp * 0.000116) +
    o_I_tmp * 0.000116) + l_I_tmp * 0.1046566) + t29_tmp_tmp * 4.0E-6) - t49_tmp
    * 0.0421722) + e_I_tmp) + t41_tmp_tmp * t12_tmp * 5.4E-5) + I_tmp *
    14.51751958424709) - t34_tmp_tmp * t5_tmp * t7_tmp * 0.0421722) - c_I_tmp *
    t6_tmp * 0.0421722) + g_I_tmp * t12_tmp * 8.0E-6) + t18_tmp_tmp_tmp * t8_tmp
    * t9_tmp * 1.89261494) - h_I_tmp * t9_tmp * 4.0E-6) - k_I_tmp * t9_tmp *
    4.0E-6) - b_I_tmp * 14.51751958424709) - m_I_tmp * t12_tmp * 0.0843444) +
                       n_I_tmp * t9_tmp * 46.16134) + o_I_tmp * t9_tmp *
                      46.16134) - n_I_tmp * t13_tmp * 0.00024) - o_I_tmp *
                    t13_tmp * 0.00024) - t29_tmp_tmp * t12_tmp * 8.0E-6) -
                  t41_tmp_tmp * t8_tmp * t9_tmp * 1.89261494) + t49_tmp *
                 t12_tmp * 0.0843444) - I_tmp * t13_tmp * 14.76973338424709) +
               t2_tmp * t5_tmp * t7_tmp * t8_tmp * t9_tmp * 14.76973338424709) +
              t69_tmp_tmp * t6_tmp * t8_tmp * t9_tmp * 14.76973338424709) +
             b_I_tmp * t27) - f_I_tmp * t5_tmp * t8_tmp * t9_tmp * 0.00024) +
    t19_tmp_tmp * t6_tmp * t7_tmp * t8_tmp * t9_tmp * 0.00024;
  b_I[7] = (((((((((((((((t3_tmp * 482.050468 - t7_tmp * 25.372381) + t42_tmp) +
                        t18) + -t17) + d) + -t21) + t23) + t24) + t71) + t26) +
                t27) + t29) + t69_tmp_tmp * 106.171082) - p_I_tmp * 5.87098) -
            q_I_tmp * 106.171082) + 1622.6810623626529;
  d_I_tmp = (t3_tmp * 241.025234 - t7_tmp * 12.6861905) + t42_tmp;
  b_I[13] = (((((((((((((d_I_tmp + t18) + -t17) + d) + -t21) + t23) + t24) + t71)
                  + t26) + t27) + t29) + t69_tmp_tmp * 53.085541) - p_I_tmp *
              2.93549) - q_I_tmp * 53.085541) + 207.22355889;
  t34_tmp = t8_tmp * t9_tmp;
  e_I_tmp = t4_tmp * 2.5327982 - t8_tmp * 0.000116;
  f_I_tmp = t3_tmp * t8_tmp * t9_tmp * 53.085541;
  b_I[19] = ((((((e_I_tmp + t35_tmp_tmp * 2.93549) + t19_tmp_tmp * 0.0421722) +
                t25_tmp * 4.0E-6) - t34_tmp * 46.16134) + t8_tmp * t13_tmp *
              0.00024) - f_I_tmp) - j_I_tmp * t9_tmp * 14.76973338424709;
  g_I_tmp = t4_tmp * 14.973735384247091 + t9_tmp * 1.89261494;
  h_I_tmp = t7_tmp * t9_tmp * 53.085541;
  b_I[25] = ((((g_I_tmp + t19_tmp_tmp * 46.16134) - j_I_tmp * 4.0E-6) - h_I_tmp)
             + t34_tmp * 0.0421722) + c_I_tmp * 53.085541;
  b_I[31] = 0.0;

  /*  INERTIA_ROW_3 - Computation of the robot specific inertia matrix row for corresponding to joint 3 of 6.  */
  /*  =========================================================================  */
  /*      */
  /*     Irow = inertia_row_3(rob,q)  */
  /*     Irow = rob.inertia_row_3(q)  */
  /*      */
  /*   Description::  */
  /*     Given a full set of joint variables this function computes the  */
  /*     inertia matrix row number 3 of 6 for Quantec Ultra SE 125.  */
  /*      */
  /*   Input::  */
  /*     rob: robot object of Quantec Ultra SE 125 specific class  */
  /*     q:  6-element vector of generalized  */
  /*          coordinates  */
  /*     Angles have to be given in radians!  */
  /*      */
  /*   Output::  */
  /*     Irow:  [1x6] row of the robot inertia matrix  */
  /*      */
  /*   Example::  */
  /*     ---  */
  /*      */
  /*   Known Bugs::  */
  /*     ---  */
  /*      */
  /*   TODO::  */
  /*     ---  */
  /*      */
  /*   References::  */
  /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
  /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
  /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
  /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
  /*      */
  /*   Authors::  */
  /*     This is an autogenerated function!  */
  /*     Code generator written by:  */
  /*     Joern Malzahn  */
  /*     2012 RST, Technische Universitaet Dortmund, Germany  */
  /*     http://www.rst.e-technik.tu-dortmund.de  */
  /*      */
  /*   See also coriolis. */
  /*      */
  /*  Copyright (C) 1993-2021, by Peter I. Corke  */
  /*  Copyright (C) 2012-2021, by Joern Malzahn  */
  /*   */
  /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
  /*   */
  /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
  /*  it under the terms of the GNU Lesser General Public License as published by  */
  /*  the Free Software Foundation, either version 3 of the License, or  */
  /*  (at your option) any later version.  */
  /*    */
  /*  RTB is distributed in the hope that it will be useful,  */
  /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
  /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
  /*  GNU Lesser General Public License for more details.  */
  /*    */
  /*  You should have received a copy of the GNU Leser General Public License  */
  /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
  /*   */
  /*  http://www.petercorke.com  */
  /*   */
  /*  The code generation module emerged during the work on a project funded by  */
  /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
  /*  acknowledge the financial support.  */
  /*  Bugfix */
  /*   In some versions the symbolic toolbox writes the constant $pi$ in */
  /*   capital letters. This way autogenerated functions might not work properly. */
  /*   To fix this issue a local variable is introduced: */
  /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
  /*     02-Mar-2021 15:15:01 */
  t18 = t8_tmp * 0.2093132;
  t21 = t19_tmp_tmp * t8_tmp * 8.0E-6;
  t23 = t5_tmp * 92.32268;
  t24 = t4_tmp * t8_tmp * t9_tmp * 0.0843444;
  t71 = t25_tmp * 3.78522988;
  t17 = d1 * t12_tmp * 0.00024;
  t26 = t12_tmp * 14.51751958424709;
  t27 = t13_tmp * 14.76973338424709;
  t29 = t12_tmp * t13_tmp * -14.76973338424709;
  k_I_tmp = t18_tmp_tmp_tmp * t4_tmp;
  l_I_tmp = t18_tmp_tmp_tmp * t5_tmp;
  m_I_tmp = t34_tmp_tmp * t7_tmp;
  n_I_tmp = t35_tmp_tmp * t6_tmp;
  o_I_tmp = t4_tmp * t6_tmp * t7_tmp;
  p_I_tmp = t18_tmp_tmp_tmp * t9_tmp;
  q_I_tmp = t23_tmp_tmp * t8_tmp;
  t49_tmp = t24_tmp_tmp * t8_tmp;
  I_tmp = t41_tmp_tmp * t9_tmp;
  b_I_tmp = k_I_tmp * t8_tmp;
  c_I_tmp = o_I_tmp * t8_tmp;
  b_I[2] = ((((((((((((((((((((((((((((((((((((t18_tmp_tmp_tmp * -0.16200394 -
    t23_tmp_tmp * 0.75031128) - t24_tmp_tmp * 0.75031128) + t41_tmp_tmp *
    0.16200394) - k_I_tmp * 0.1046566) - l_I_tmp * 4.0E-6) - m_I_tmp * 2.5327982)
    - n_I_tmp * 2.5327982) + p_I_tmp * 0.0421722) - t18_tmp_tmp_tmp * t12_tmp *
    5.4E-5) + q_I_tmp * 0.000116) + t49_tmp * 0.000116) + o_I_tmp * 0.1046566) +
    t29_tmp_tmp * 4.0E-6) - I_tmp * 0.0421722) + t41_tmp_tmp * t12_tmp * 5.4E-5)
    + b_I_tmp * 14.51751958424709) - t34_tmp_tmp * t5_tmp * t7_tmp * 0.0421722)
    - t35_tmp_tmp * t5_tmp * t6_tmp * 0.0421722) + l_I_tmp * t12_tmp * 8.0E-6) +
    t18_tmp_tmp_tmp * t8_tmp * t9_tmp * 1.89261494) - m_I_tmp * t9_tmp * 4.0E-6)
    - n_I_tmp * t9_tmp * 4.0E-6) - c_I_tmp * 14.51751958424709) - p_I_tmp *
                        t12_tmp * 0.0843444) + q_I_tmp * t9_tmp * 46.16134) +
                      t49_tmp * t9_tmp * 46.16134) - q_I_tmp * t13_tmp * 0.00024)
                    - t49_tmp * t13_tmp * 0.00024) - t29_tmp_tmp * t12_tmp *
                   8.0E-6) - t41_tmp_tmp * t8_tmp * t9_tmp * 1.89261494) + I_tmp
                 * t12_tmp * 0.0843444) - b_I_tmp * t13_tmp * 14.76973338424709)
               + t2_tmp * t5_tmp * t7_tmp * t8_tmp * t9_tmp * 14.76973338424709)
              + t69_tmp_tmp * t6_tmp * t8_tmp * t9_tmp * 14.76973338424709) +
             c_I_tmp * t27) - k_I_tmp * t5_tmp * t8_tmp * t9_tmp * 0.00024) +
    t19_tmp_tmp * t6_tmp * t7_tmp * t8_tmp * t9_tmp * 0.00024;
  b_I[8] = (((((((((((((d_I_tmp + t18) + -t17) + d) + -t21) + t23) + t24) + t71)
                 + t26) + t27) + t29) + t69_tmp_tmp * 53.085541) - t7_tmp *
             t8_tmp * 2.93549) - t4_tmp * t7_tmp * t9_tmp * 53.085541) +
    207.22355889;
  b_I[14] = ((((((((((t42_tmp + t18) + -t17) + d) + -t21) + t23) + t24) + t71) +
               t26) + t27) + t29) + 958.5544700011111;
  b_I[20] = ((((e_I_tmp + t19_tmp_tmp * 0.0421722) + t25_tmp * 4.0E-6) - t34_tmp
              * 46.16134) + t8_tmp * t13_tmp * 0.00024) - j_I_tmp * t9_tmp *
    14.76973338424709;
  b_I[26] = ((g_I_tmp + t19_tmp_tmp * 46.16134) - j_I_tmp * 4.0E-6) + t34_tmp *
    0.0421722;
  b_I[32] = 0.0;

  /*  INERTIA_ROW_4 - Computation of the robot specific inertia matrix row for corresponding to joint 4 of 6.  */
  /*  =========================================================================  */
  /*      */
  /*     Irow = inertia_row_4(rob,q)  */
  /*     Irow = rob.inertia_row_4(q)  */
  /*      */
  /*   Description::  */
  /*     Given a full set of joint variables this function computes the  */
  /*     inertia matrix row number 4 of 6 for Quantec Ultra SE 125.  */
  /*      */
  /*   Input::  */
  /*     rob: robot object of Quantec Ultra SE 125 specific class  */
  /*     q:  6-element vector of generalized  */
  /*          coordinates  */
  /*     Angles have to be given in radians!  */
  /*      */
  /*   Output::  */
  /*     Irow:  [1x6] row of the robot inertia matrix  */
  /*      */
  /*   Example::  */
  /*     ---  */
  /*      */
  /*   Known Bugs::  */
  /*     ---  */
  /*      */
  /*   TODO::  */
  /*     ---  */
  /*      */
  /*   References::  */
  /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
  /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
  /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
  /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
  /*      */
  /*   Authors::  */
  /*     This is an autogenerated function!  */
  /*     Code generator written by:  */
  /*     Joern Malzahn  */
  /*     2012 RST, Technische Universitaet Dortmund, Germany  */
  /*     http://www.rst.e-technik.tu-dortmund.de  */
  /*      */
  /*   See also coriolis. */
  /*      */
  /*  Copyright (C) 1993-2021, by Peter I. Corke  */
  /*  Copyright (C) 2012-2021, by Joern Malzahn  */
  /*   */
  /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
  /*   */
  /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
  /*  it under the terms of the GNU Lesser General Public License as published by  */
  /*  the Free Software Foundation, either version 3 of the License, or  */
  /*  (at your option) any later version.  */
  /*    */
  /*  RTB is distributed in the hope that it will be useful,  */
  /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
  /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
  /*  GNU Lesser General Public License for more details.  */
  /*    */
  /*  You should have received a copy of the GNU Leser General Public License  */
  /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
  /*   */
  /*  http://www.petercorke.com  */
  /*   */
  /*  The code generation module emerged during the work on a project funded by  */
  /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
  /*  acknowledge the financial support.  */
  /*  Bugfix */
  /*   In some versions the symbolic toolbox writes the constant $pi$ in */
  /*   capital letters. This way autogenerated functions might not work properly. */
  /*   To fix this issue a local variable is introduced: */
  /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
  /*     02-Mar-2021 15:15:02 */
  d_I_tmp = t18_tmp_tmp_tmp * t4_tmp;
  e_I_tmp = t18_tmp_tmp_tmp * t8_tmp;
  g_I_tmp = t4_tmp * t6_tmp * t7_tmp;
  k_I_tmp = t6_tmp * t7_tmp * t8_tmp;
  b_I[3] = ((((((((((((((((((((((((((t8_tmp * 0.89341 - t23_tmp_tmp *
    15.44737218424709) - t24_tmp_tmp * 15.44737218424709) + i_I_tmp) + t25_tmp *
    16.156469) + d_I_tmp * 0.000116) + e_I_tmp * 2.5327982) + t34_tmp_tmp *
    t9_tmp * 53.085541) - t23_tmp_tmp * t8_tmp * 0.1046566) - t24_tmp_tmp *
    t8_tmp * 0.1046566) - g_I_tmp * 0.000116) + t23_tmp_tmp * t13_tmp *
    14.76973338424709) + t24_tmp_tmp * t13_tmp * 14.76973338424709) - k_I_tmp *
    2.5327982) + d_I_tmp * t9_tmp * 46.16134) + t18_tmp_tmp_tmp * t5_tmp *
                       t8_tmp * 0.0421722) - d_I_tmp * t13_tmp * 0.00024) +
                     e_I_tmp * t9_tmp * 4.0E-6) - t34_tmp_tmp * t7_tmp * t9_tmp *
                    1.89261494) - t35_tmp_tmp * t6_tmp * t9_tmp * 1.89261494) +
                  t2_tmp * t5_tmp * t7_tmp * t9_tmp * 0.00024) + t3_tmp * t5_tmp
                 * t6_tmp * t9_tmp * 0.00024) - g_I_tmp * t9_tmp * 46.16134) -
               t5_tmp * t6_tmp * t7_tmp * t8_tmp * 0.0421722) + g_I_tmp *
              t13_tmp * 0.00024) - k_I_tmp * t9_tmp * 4.0E-6) + d_I_tmp * t5_tmp
            * t9_tmp * 14.76973338424709) - t19_tmp_tmp * t6_tmp * t7_tmp *
    t9_tmp * 14.76973338424709;
  d_I_tmp = (((((t8_tmp * t13_tmp * 0.00024 + t25_tmp * 4.0E-6) + t19_tmp_tmp *
                0.0421722) + -(t8_tmp * t9_tmp * 46.16134)) + t4_tmp * 2.5327982)
             + -(t8_tmp * 0.000116)) + -(t5_tmp * t8_tmp * t9_tmp *
    14.76973338424709);
  b_I[9] = (d_I_tmp + t35_tmp_tmp * 2.93549) - f_I_tmp;
  b_I[15] = d_I_tmp;
  b_I[21] = (t13_tmp * -14.76973338424709 - t42_tmp) + 99.942302184247083;
  d_I_tmp = t5_tmp * 0.0421722 + t9_tmp * 4.0E-6;
  b_I[27] = d_I_tmp;
  b_I[33] = 0.0;

  /*  INERTIA_ROW_5 - Computation of the robot specific inertia matrix row for corresponding to joint 5 of 6.  */
  /*  =========================================================================  */
  /*      */
  /*     Irow = inertia_row_5(rob,q)  */
  /*     Irow = rob.inertia_row_5(q)  */
  /*      */
  /*   Description::  */
  /*     Given a full set of joint variables this function computes the  */
  /*     inertia matrix row number 5 of 6 for Quantec Ultra SE 125.  */
  /*      */
  /*   Input::  */
  /*     rob: robot object of Quantec Ultra SE 125 specific class  */
  /*     q:  6-element vector of generalized  */
  /*          coordinates  */
  /*     Angles have to be given in radians!  */
  /*      */
  /*   Output::  */
  /*     Irow:  [1x6] row of the robot inertia matrix  */
  /*      */
  /*   Example::  */
  /*     ---  */
  /*      */
  /*   Known Bugs::  */
  /*     ---  */
  /*      */
  /*   TODO::  */
  /*     ---  */
  /*      */
  /*   References::  */
  /*     1) Robot Modeling and Control - Spong, Hutchinson, Vidyasagar  */
  /*     2) Modelling and Control of Robot Manipulators - Sciavicco, Siciliano  */
  /*     3) Introduction to Robotics, Mechanics and Control - Craig  */
  /*     4) Modeling, Identification & Control of Robots - Khalil & Dombre  */
  /*      */
  /*   Authors::  */
  /*     This is an autogenerated function!  */
  /*     Code generator written by:  */
  /*     Joern Malzahn  */
  /*     2012 RST, Technische Universitaet Dortmund, Germany  */
  /*     http://www.rst.e-technik.tu-dortmund.de  */
  /*      */
  /*   See also coriolis. */
  /*      */
  /*  Copyright (C) 1993-2021, by Peter I. Corke  */
  /*  Copyright (C) 2012-2021, by Joern Malzahn  */
  /*   */
  /*  This file has been automatically generated with The Robotics Toolbox for Matlab (RTB).  */
  /*   */
  /*  RTB and code generated with RTB is free software: you can redistribute it and/or modify  */
  /*  it under the terms of the GNU Lesser General Public License as published by  */
  /*  the Free Software Foundation, either version 3 of the License, or  */
  /*  (at your option) any later version.  */
  /*    */
  /*  RTB is distributed in the hope that it will be useful,  */
  /*  but WITHOUT ANY WARRANTY; without even the implied warranty of  */
  /*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  */
  /*  GNU Lesser General Public License for more details.  */
  /*    */
  /*  You should have received a copy of the GNU Leser General Public License  */
  /*  along with RTB.  If not, see <http://www.gnu.org/licenses/>.  */
  /*   */
  /*  http://www.petercorke.com  */
  /*   */
  /*  The code generation module emerged during the work on a project funded by  */
  /*  the German Research Foundation (DFG, BE1569/7-1). The authors gratefully   */
  /*  acknowledge the financial support.  */
  /*  Bugfix */
  /*   In some versions the symbolic toolbox writes the constant $pi$ in */
  /*   capital letters. This way autogenerated functions might not work properly. */
  /*   To fix this issue a local variable is introduced: */
  /*     This function was generated by the Symbolic Math Toolbox version 8.5. */
  /*     02-Mar-2021 15:15:02 */
  e_I_tmp = t18_tmp_tmp_tmp * t4_tmp;
  f_I_tmp = t68_tmp_tmp * t7_tmp;
  g_I_tmp = t3_tmp * t5_tmp * t6_tmp;
  b_I[4] = ((((((((((((((j_I_tmp * 16.156469 + t18_tmp_tmp_tmp * t8_tmp *
    14.973735384247091) - f_I_tmp * 0.0421722) - g_I_tmp * 0.0421722) +
                      t68_tmp_tmp * t8_tmp * 53.085541) - t2_tmp * t7_tmp *
                     t9_tmp * 4.0E-6) - t3_tmp * t6_tmp * t9_tmp * 4.0E-6) -
                   t6_tmp * t7_tmp * t8_tmp * 14.973735384247091) + e_I_tmp *
                  t5_tmp * 4.0E-6) - e_I_tmp * t9_tmp * 0.0421722) +
                t18_tmp_tmp_tmp * t5_tmp * t8_tmp * 46.16134) - f_I_tmp * t8_tmp
               * 1.89261494) - g_I_tmp * t8_tmp * 1.89261494) - t19_tmp_tmp *
             t6_tmp * t7_tmp * 4.0E-6) + t4_tmp * t6_tmp * t7_tmp * t9_tmp *
            0.0421722) - t5_tmp * t6_tmp * t7_tmp * t8_tmp * 46.16134;
  e_I_tmp = (((-(j_I_tmp * 4.0E-6) + t19_tmp_tmp * 46.16134) + t8_tmp * t9_tmp *
              0.0421722) + t9_tmp * 1.89261494) + t4_tmp * 14.973735384247091;
  b_I[10] = (e_I_tmp - h_I_tmp) + t3_tmp * t4_tmp * t5_tmp * 53.085541;
  b_I[16] = e_I_tmp;
  b_I[22] = d_I_tmp;
  b_I[28] = 114.3056435928639;
  b_I[34] = 0.0;
  for (i = 0; i < 6; i++) {
    b_I[6 * i + 5] = dv[i];
  }
}

/* End of code generation (inertia_125.c) */
